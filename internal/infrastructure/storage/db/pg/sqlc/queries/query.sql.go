// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
)

const deleteSwapsByTradeId = `-- name: DeleteSwapsByTradeId :exec
DELETE FROM swap WHERE fk_trade_id = $1
`

func (q *Queries) DeleteSwapsByTradeId(ctx context.Context, fkTradeID string) error {
	_, err := q.db.Exec(ctx, deleteSwapsByTradeId, fkTradeID)
	return err
}

const getAllMarkets = `-- name: GetAllMarkets :many
SELECT name, base_asset, quote_asset, base_asset_precision, quote_asset_precision, tradable, strategy_type, base_price, quote_price, active, id, base_asset_fee, quote_asset_fee, type, fk_market_name FROM market m inner join market_fee f on m.name = f.fk_market_name and active = true
`

type GetAllMarketsRow struct {
	Name                string
	BaseAsset           string
	QuoteAsset          string
	BaseAssetPrecision  int32
	QuoteAssetPrecision int32
	Tradable            bool
	StrategyType        int32
	BasePrice           float64
	QuotePrice          float64
	Active              bool
	ID                  int32
	BaseAssetFee        int64
	QuoteAssetFee       int64
	Type                string
	FkMarketName        string
}

func (q *Queries) GetAllMarkets(ctx context.Context) ([]GetAllMarketsRow, error) {
	rows, err := q.db.Query(ctx, getAllMarkets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllMarketsRow
	for rows.Next() {
		var i GetAllMarketsRow
		if err := rows.Scan(
			&i.Name,
			&i.BaseAsset,
			&i.QuoteAsset,
			&i.BaseAssetPrecision,
			&i.QuoteAssetPrecision,
			&i.Tradable,
			&i.StrategyType,
			&i.BasePrice,
			&i.QuotePrice,
			&i.Active,
			&i.ID,
			&i.BaseAssetFee,
			&i.QuoteAssetFee,
			&i.Type,
			&i.FkMarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTrades = `-- name: GetAllTrades :many
SELECT t.id, t.type, t.fee_asset, t.fee_amount, t.trader_pubkey, t.status_code, t.status_failed, t.pset_base64, t.tx_id, t.tx_hex, t.expiry_time, t.settlement_time, t.base_price, t.quote_price, t.fk_market_name, m.name, m.base_asset, m.quote_asset,
       s.id as swap_id, s.message, s.timestamp, s.type as swap_type, f.base_asset_fee,
       f.quote_asset_fee, f.type as fee_type
FROM trade t left join swap s on t.id = s.fk_trade_id inner join
     market m on m.name = t.fk_market_name left join trade_fee f on t.id = f.fk_trade_id
order by t.id DESC LIMIT $1 OFFSET $2
`

type GetAllTradesParams struct {
	Limit  int32
	Offset int32
}

type GetAllTradesRow struct {
	ID             string
	Type           int32
	FeeAsset       string
	FeeAmount      int64
	TraderPubkey   []byte
	StatusCode     int32
	StatusFailed   bool
	PsetBase64     string
	TxID           sql.NullString
	TxHex          string
	ExpiryTime     sql.NullInt64
	SettlementTime sql.NullInt64
	BasePrice      sql.NullFloat64
	QuotePrice     sql.NullFloat64
	FkMarketName   string
	Name           string
	BaseAsset      string
	QuoteAsset     string
	SwapID         string
	Message        []byte
	Timestamp      int64
	SwapType       string
	BaseAssetFee   sql.NullInt64
	QuoteAssetFee  sql.NullInt64
	FeeType        sql.NullString
}

func (q *Queries) GetAllTrades(ctx context.Context, arg GetAllTradesParams) ([]GetAllTradesRow, error) {
	rows, err := q.db.Query(ctx, getAllTrades, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTradesRow
	for rows.Next() {
		var i GetAllTradesRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.FeeAsset,
			&i.FeeAmount,
			&i.TraderPubkey,
			&i.StatusCode,
			&i.StatusFailed,
			&i.PsetBase64,
			&i.TxID,
			&i.TxHex,
			&i.ExpiryTime,
			&i.SettlementTime,
			&i.BasePrice,
			&i.QuotePrice,
			&i.FkMarketName,
			&i.Name,
			&i.BaseAsset,
			&i.QuoteAsset,
			&i.SwapID,
			&i.Message,
			&i.Timestamp,
			&i.SwapType,
			&i.BaseAssetFee,
			&i.QuoteAssetFee,
			&i.FeeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTradesByMarket = `-- name: GetAllTradesByMarket :many
SELECT t.id, t.type, t.fee_asset, t.fee_amount, t.trader_pubkey, t.status_code, t.status_failed, t.pset_base64, t.tx_id, t.tx_hex, t.expiry_time, t.settlement_time, t.base_price, t.quote_price, t.fk_market_name, m.name, m.base_asset, m.quote_asset,
       s.id as swap_id, s.message, s.timestamp, s.type as swap_type, f.base_asset_fee,
        f.quote_asset_fee, f.type as fee_type
FROM trade t left join swap s on t.id = s.fk_trade_id inner join
     market m on m.name = t.fk_market_name left join trade_fee f on t.id = f.fk_trade_id
WHERE m.name = $1 order by t.id DESC LIMIT $2 OFFSET $3
`

type GetAllTradesByMarketParams struct {
	Name   string
	Limit  int32
	Offset int32
}

type GetAllTradesByMarketRow struct {
	ID             string
	Type           int32
	FeeAsset       string
	FeeAmount      int64
	TraderPubkey   []byte
	StatusCode     int32
	StatusFailed   bool
	PsetBase64     string
	TxID           sql.NullString
	TxHex          string
	ExpiryTime     sql.NullInt64
	SettlementTime sql.NullInt64
	BasePrice      sql.NullFloat64
	QuotePrice     sql.NullFloat64
	FkMarketName   string
	Name           string
	BaseAsset      string
	QuoteAsset     string
	SwapID         string
	Message        []byte
	Timestamp      int64
	SwapType       string
	BaseAssetFee   sql.NullInt64
	QuoteAssetFee  sql.NullInt64
	FeeType        sql.NullString
}

func (q *Queries) GetAllTradesByMarket(ctx context.Context, arg GetAllTradesByMarketParams) ([]GetAllTradesByMarketRow, error) {
	rows, err := q.db.Query(ctx, getAllTradesByMarket, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTradesByMarketRow
	for rows.Next() {
		var i GetAllTradesByMarketRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.FeeAsset,
			&i.FeeAmount,
			&i.TraderPubkey,
			&i.StatusCode,
			&i.StatusFailed,
			&i.PsetBase64,
			&i.TxID,
			&i.TxHex,
			&i.ExpiryTime,
			&i.SettlementTime,
			&i.BasePrice,
			&i.QuotePrice,
			&i.FkMarketName,
			&i.Name,
			&i.BaseAsset,
			&i.QuoteAsset,
			&i.SwapID,
			&i.Message,
			&i.Timestamp,
			&i.SwapType,
			&i.BaseAssetFee,
			&i.QuoteAssetFee,
			&i.FeeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTransactions = `-- name: GetAllTransactions :many
SELECT t.type, t.account_name, t.tx_id, t.timestamp, taa.asset, taa.amount
FROM transaction t left join transaction_asset_amount taa on t.id = taa.fk_transaction_id
WHERE t.type = $1 ORDER BY timestamp DESC LIMIT $2 OFFSET $3
`

type GetAllTransactionsParams struct {
	Type   string
	Limit  int32
	Offset int32
}

type GetAllTransactionsRow struct {
	Type        string
	AccountName string
	TxID        string
	Timestamp   int64
	Asset       sql.NullString
	Amount      sql.NullInt64
}

func (q *Queries) GetAllTransactions(ctx context.Context, arg GetAllTransactionsParams) ([]GetAllTransactionsRow, error) {
	rows, err := q.db.Query(ctx, getAllTransactions, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTransactionsRow
	for rows.Next() {
		var i GetAllTransactionsRow
		if err := rows.Scan(
			&i.Type,
			&i.AccountName,
			&i.TxID,
			&i.Timestamp,
			&i.Asset,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTransactionsForAccountNameAndPage = `-- name: GetAllTransactionsForAccountNameAndPage :many
SELECT t.type, t.account_name, t.tx_id, t.timestamp, taa.asset, taa.amount
FROM transaction t left join transaction_asset_amount taa on t.id = taa.fk_transaction_id
WHERE t.type = $1 AND account_name = $2 ORDER BY timestamp DESC LIMIT $3 OFFSET $4
`

type GetAllTransactionsForAccountNameAndPageParams struct {
	Type        string
	AccountName string
	Limit       int32
	Offset      int32
}

type GetAllTransactionsForAccountNameAndPageRow struct {
	Type        string
	AccountName string
	TxID        string
	Timestamp   int64
	Asset       sql.NullString
	Amount      sql.NullInt64
}

func (q *Queries) GetAllTransactionsForAccountNameAndPage(ctx context.Context, arg GetAllTransactionsForAccountNameAndPageParams) ([]GetAllTransactionsForAccountNameAndPageRow, error) {
	rows, err := q.db.Query(ctx, getAllTransactionsForAccountNameAndPage,
		arg.Type,
		arg.AccountName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTransactionsForAccountNameAndPageRow
	for rows.Next() {
		var i GetAllTransactionsForAccountNameAndPageRow
		if err := rows.Scan(
			&i.Type,
			&i.AccountName,
			&i.TxID,
			&i.Timestamp,
			&i.Asset,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeeByMarketName = `-- name: GetFeeByMarketName :one
SELECT id, base_asset_fee, quote_asset_fee, type, fk_market_name FROM market_fee WHERE fk_market_name = $1
`

func (q *Queries) GetFeeByMarketName(ctx context.Context, fkMarketName string) (MarketFee, error) {
	row := q.db.QueryRow(ctx, getFeeByMarketName, fkMarketName)
	var i MarketFee
	err := row.Scan(
		&i.ID,
		&i.BaseAssetFee,
		&i.QuoteAssetFee,
		&i.Type,
		&i.FkMarketName,
	)
	return i, err
}

const getMarketByBaseAndQuoteAsset = `-- name: GetMarketByBaseAndQuoteAsset :many
SELECT name, base_asset, quote_asset, base_asset_precision, quote_asset_precision, tradable, strategy_type, base_price, quote_price, active, id, base_asset_fee, quote_asset_fee, type, fk_market_name from market m inner join market_fee f on m.name = f.fk_market_name where
base_asset = $1 and quote_asset = $2 and active = true
`

type GetMarketByBaseAndQuoteAssetParams struct {
	BaseAsset  string
	QuoteAsset string
}

type GetMarketByBaseAndQuoteAssetRow struct {
	Name                string
	BaseAsset           string
	QuoteAsset          string
	BaseAssetPrecision  int32
	QuoteAssetPrecision int32
	Tradable            bool
	StrategyType        int32
	BasePrice           float64
	QuotePrice          float64
	Active              bool
	ID                  int32
	BaseAssetFee        int64
	QuoteAssetFee       int64
	Type                string
	FkMarketName        string
}

func (q *Queries) GetMarketByBaseAndQuoteAsset(ctx context.Context, arg GetMarketByBaseAndQuoteAssetParams) ([]GetMarketByBaseAndQuoteAssetRow, error) {
	rows, err := q.db.Query(ctx, getMarketByBaseAndQuoteAsset, arg.BaseAsset, arg.QuoteAsset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMarketByBaseAndQuoteAssetRow
	for rows.Next() {
		var i GetMarketByBaseAndQuoteAssetRow
		if err := rows.Scan(
			&i.Name,
			&i.BaseAsset,
			&i.QuoteAsset,
			&i.BaseAssetPrecision,
			&i.QuoteAssetPrecision,
			&i.Tradable,
			&i.StrategyType,
			&i.BasePrice,
			&i.QuotePrice,
			&i.Active,
			&i.ID,
			&i.BaseAssetFee,
			&i.QuoteAssetFee,
			&i.Type,
			&i.FkMarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMarketByName = `-- name: GetMarketByName :many
SELECT name, base_asset, quote_asset, base_asset_precision, quote_asset_precision, tradable, strategy_type, base_price, quote_price, active, id, base_asset_fee, quote_asset_fee, type, fk_market_name from market m inner join market_fee f on m.name = f.fk_market_name where name = $1 and active = true
`

type GetMarketByNameRow struct {
	Name                string
	BaseAsset           string
	QuoteAsset          string
	BaseAssetPrecision  int32
	QuoteAssetPrecision int32
	Tradable            bool
	StrategyType        int32
	BasePrice           float64
	QuotePrice          float64
	Active              bool
	ID                  int32
	BaseAssetFee        int64
	QuoteAssetFee       int64
	Type                string
	FkMarketName        string
}

func (q *Queries) GetMarketByName(ctx context.Context, name string) ([]GetMarketByNameRow, error) {
	rows, err := q.db.Query(ctx, getMarketByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMarketByNameRow
	for rows.Next() {
		var i GetMarketByNameRow
		if err := rows.Scan(
			&i.Name,
			&i.BaseAsset,
			&i.QuoteAsset,
			&i.BaseAssetPrecision,
			&i.QuoteAssetPrecision,
			&i.Tradable,
			&i.StrategyType,
			&i.BasePrice,
			&i.QuotePrice,
			&i.Active,
			&i.ID,
			&i.BaseAssetFee,
			&i.QuoteAssetFee,
			&i.Type,
			&i.FkMarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTradableMarkets = `-- name: GetTradableMarkets :many
SELECT name, base_asset, quote_asset, base_asset_precision, quote_asset_precision, tradable, strategy_type, base_price, quote_price, active, id, base_asset_fee, quote_asset_fee, type, fk_market_name FROM market m inner join market_fee f on m.name = f.fk_market_name
where tradable = true and active = true
`

type GetTradableMarketsRow struct {
	Name                string
	BaseAsset           string
	QuoteAsset          string
	BaseAssetPrecision  int32
	QuoteAssetPrecision int32
	Tradable            bool
	StrategyType        int32
	BasePrice           float64
	QuotePrice          float64
	Active              bool
	ID                  int32
	BaseAssetFee        int64
	QuoteAssetFee       int64
	Type                string
	FkMarketName        string
}

func (q *Queries) GetTradableMarkets(ctx context.Context) ([]GetTradableMarketsRow, error) {
	rows, err := q.db.Query(ctx, getTradableMarkets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTradableMarketsRow
	for rows.Next() {
		var i GetTradableMarketsRow
		if err := rows.Scan(
			&i.Name,
			&i.BaseAsset,
			&i.QuoteAsset,
			&i.BaseAssetPrecision,
			&i.QuoteAssetPrecision,
			&i.Tradable,
			&i.StrategyType,
			&i.BasePrice,
			&i.QuotePrice,
			&i.Active,
			&i.ID,
			&i.BaseAssetFee,
			&i.QuoteAssetFee,
			&i.Type,
			&i.FkMarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTradeById = `-- name: GetTradeById :many
SELECT t.id, t.type, t.fee_asset, t.fee_amount, t.trader_pubkey, t.status_code, t.status_failed, t.pset_base64, t.tx_id, t.tx_hex, t.expiry_time, t.settlement_time, t.base_price, t.quote_price, t.fk_market_name, m.name, m.base_asset, m.quote_asset,
s.id as swap_id, s.message, s.timestamp, s.type as swap_type, f.base_asset_fee,
       f.quote_asset_fee, f.type as fee_type
FROM trade t left join swap s on t.id = s.fk_trade_id inner join
market m on m.name = t.fk_market_name left join trade_fee f on t.id = f.fk_trade_id
WHERE t.id = $1
`

type GetTradeByIdRow struct {
	ID             string
	Type           int32
	FeeAsset       string
	FeeAmount      int64
	TraderPubkey   []byte
	StatusCode     int32
	StatusFailed   bool
	PsetBase64     string
	TxID           sql.NullString
	TxHex          string
	ExpiryTime     sql.NullInt64
	SettlementTime sql.NullInt64
	BasePrice      sql.NullFloat64
	QuotePrice     sql.NullFloat64
	FkMarketName   string
	Name           string
	BaseAsset      string
	QuoteAsset     string
	SwapID         string
	Message        []byte
	Timestamp      int64
	SwapType       string
	BaseAssetFee   sql.NullInt64
	QuoteAssetFee  sql.NullInt64
	FeeType        sql.NullString
}

func (q *Queries) GetTradeById(ctx context.Context, id string) ([]GetTradeByIdRow, error) {
	rows, err := q.db.Query(ctx, getTradeById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTradeByIdRow
	for rows.Next() {
		var i GetTradeByIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.FeeAsset,
			&i.FeeAmount,
			&i.TraderPubkey,
			&i.StatusCode,
			&i.StatusFailed,
			&i.PsetBase64,
			&i.TxID,
			&i.TxHex,
			&i.ExpiryTime,
			&i.SettlementTime,
			&i.BasePrice,
			&i.QuotePrice,
			&i.FkMarketName,
			&i.Name,
			&i.BaseAsset,
			&i.QuoteAsset,
			&i.SwapID,
			&i.Message,
			&i.Timestamp,
			&i.SwapType,
			&i.BaseAssetFee,
			&i.QuoteAssetFee,
			&i.FeeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTradeBySwapAcceptId = `-- name: GetTradeBySwapAcceptId :many
SELECT t.id, t.type, t.fee_asset, t.fee_amount, t.trader_pubkey, t.status_code, t.status_failed, t.pset_base64, t.tx_id, t.tx_hex, t.expiry_time, t.settlement_time, t.base_price, t.quote_price, t.fk_market_name, m.name, m.base_asset, m.quote_asset,
       s.id as swap_id, s.message, s.timestamp, s.type as swap_type, f.base_asset_fee,
       f.quote_asset_fee, f.type as fee_type
FROM trade t left join swap s on t.id = s.fk_trade_id inner join
     market m on m.name = t.fk_market_name left join trade_fee f on t.id = f.fk_trade_id
WHERE t.id in (select t.id from trade t inner join swap s on t.id = s.fk_trade_id where s.id = $1)
`

type GetTradeBySwapAcceptIdRow struct {
	ID             string
	Type           int32
	FeeAsset       string
	FeeAmount      int64
	TraderPubkey   []byte
	StatusCode     int32
	StatusFailed   bool
	PsetBase64     string
	TxID           sql.NullString
	TxHex          string
	ExpiryTime     sql.NullInt64
	SettlementTime sql.NullInt64
	BasePrice      sql.NullFloat64
	QuotePrice     sql.NullFloat64
	FkMarketName   string
	Name           string
	BaseAsset      string
	QuoteAsset     string
	SwapID         string
	Message        []byte
	Timestamp      int64
	SwapType       string
	BaseAssetFee   sql.NullInt64
	QuoteAssetFee  sql.NullInt64
	FeeType        sql.NullString
}

func (q *Queries) GetTradeBySwapAcceptId(ctx context.Context, id string) ([]GetTradeBySwapAcceptIdRow, error) {
	rows, err := q.db.Query(ctx, getTradeBySwapAcceptId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTradeBySwapAcceptIdRow
	for rows.Next() {
		var i GetTradeBySwapAcceptIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.FeeAsset,
			&i.FeeAmount,
			&i.TraderPubkey,
			&i.StatusCode,
			&i.StatusFailed,
			&i.PsetBase64,
			&i.TxID,
			&i.TxHex,
			&i.ExpiryTime,
			&i.SettlementTime,
			&i.BasePrice,
			&i.QuotePrice,
			&i.FkMarketName,
			&i.Name,
			&i.BaseAsset,
			&i.QuoteAsset,
			&i.SwapID,
			&i.Message,
			&i.Timestamp,
			&i.SwapType,
			&i.BaseAssetFee,
			&i.QuoteAssetFee,
			&i.FeeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTradeByTxId = `-- name: GetTradeByTxId :many
SELECT t.id, t.type, t.fee_asset, t.fee_amount, t.trader_pubkey, t.status_code, t.status_failed, t.pset_base64, t.tx_id, t.tx_hex, t.expiry_time, t.settlement_time, t.base_price, t.quote_price, t.fk_market_name, m.name, m.base_asset, m.quote_asset,
       s.id as swap_id, s.message, s.timestamp, s.type as swap_type, f.base_asset_fee,
       f.quote_asset_fee, f.type as fee_type
FROM trade t left join swap s on t.id = s.fk_trade_id inner join
     market m on m.name = t.fk_market_name left join trade_fee f on t.id = f.fk_trade_id
WHERE t.tx_id = $1
`

type GetTradeByTxIdRow struct {
	ID             string
	Type           int32
	FeeAsset       string
	FeeAmount      int64
	TraderPubkey   []byte
	StatusCode     int32
	StatusFailed   bool
	PsetBase64     string
	TxID           sql.NullString
	TxHex          string
	ExpiryTime     sql.NullInt64
	SettlementTime sql.NullInt64
	BasePrice      sql.NullFloat64
	QuotePrice     sql.NullFloat64
	FkMarketName   string
	Name           string
	BaseAsset      string
	QuoteAsset     string
	SwapID         string
	Message        []byte
	Timestamp      int64
	SwapType       string
	BaseAssetFee   sql.NullInt64
	QuoteAssetFee  sql.NullInt64
	FeeType        sql.NullString
}

func (q *Queries) GetTradeByTxId(ctx context.Context, txID sql.NullString) ([]GetTradeByTxIdRow, error) {
	rows, err := q.db.Query(ctx, getTradeByTxId, txID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTradeByTxIdRow
	for rows.Next() {
		var i GetTradeByTxIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.FeeAsset,
			&i.FeeAmount,
			&i.TraderPubkey,
			&i.StatusCode,
			&i.StatusFailed,
			&i.PsetBase64,
			&i.TxID,
			&i.TxHex,
			&i.ExpiryTime,
			&i.SettlementTime,
			&i.BasePrice,
			&i.QuotePrice,
			&i.FkMarketName,
			&i.Name,
			&i.BaseAsset,
			&i.QuoteAsset,
			&i.SwapID,
			&i.Message,
			&i.Timestamp,
			&i.SwapType,
			&i.BaseAssetFee,
			&i.QuoteAssetFee,
			&i.FeeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTradesByMarketAndStatus = `-- name: GetTradesByMarketAndStatus :many
SELECT t.id, t.type, t.fee_asset, t.fee_amount, t.trader_pubkey, t.status_code, t.status_failed, t.pset_base64, t.tx_id, t.tx_hex, t.expiry_time, t.settlement_time, t.base_price, t.quote_price, t.fk_market_name, m.name, m.base_asset, m.quote_asset,
       s.id as swap_id, s.message, s.timestamp, s.type as swap_type, f.base_asset_fee,
       f.quote_asset_fee, f.type as fee_type
FROM trade t left join swap s on t.id = s.fk_trade_id inner join
     market m on m.name = t.fk_market_name left join trade_fee f on t.id = f.fk_trade_id
WHERE m.name = $1 AND t.status_code = $2 and t.status_failed = $3 order by t.id DESC LIMIT $4 OFFSET $5
`

type GetTradesByMarketAndStatusParams struct {
	Name         string
	StatusCode   int32
	StatusFailed bool
	Limit        int32
	Offset       int32
}

type GetTradesByMarketAndStatusRow struct {
	ID             string
	Type           int32
	FeeAsset       string
	FeeAmount      int64
	TraderPubkey   []byte
	StatusCode     int32
	StatusFailed   bool
	PsetBase64     string
	TxID           sql.NullString
	TxHex          string
	ExpiryTime     sql.NullInt64
	SettlementTime sql.NullInt64
	BasePrice      sql.NullFloat64
	QuotePrice     sql.NullFloat64
	FkMarketName   string
	Name           string
	BaseAsset      string
	QuoteAsset     string
	SwapID         string
	Message        []byte
	Timestamp      int64
	SwapType       string
	BaseAssetFee   sql.NullInt64
	QuoteAssetFee  sql.NullInt64
	FeeType        sql.NullString
}

func (q *Queries) GetTradesByMarketAndStatus(ctx context.Context, arg GetTradesByMarketAndStatusParams) ([]GetTradesByMarketAndStatusRow, error) {
	rows, err := q.db.Query(ctx, getTradesByMarketAndStatus,
		arg.Name,
		arg.StatusCode,
		arg.StatusFailed,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTradesByMarketAndStatusRow
	for rows.Next() {
		var i GetTradesByMarketAndStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.FeeAsset,
			&i.FeeAmount,
			&i.TraderPubkey,
			&i.StatusCode,
			&i.StatusFailed,
			&i.PsetBase64,
			&i.TxID,
			&i.TxHex,
			&i.ExpiryTime,
			&i.SettlementTime,
			&i.BasePrice,
			&i.QuotePrice,
			&i.FkMarketName,
			&i.Name,
			&i.BaseAsset,
			&i.QuoteAsset,
			&i.SwapID,
			&i.Message,
			&i.Timestamp,
			&i.SwapType,
			&i.BaseAssetFee,
			&i.QuoteAssetFee,
			&i.FeeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const inactivateMarket = `-- name: InactivateMarket :exec
UPDATE market SET active=false WHERE name = $1
`

func (q *Queries) InactivateMarket(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, inactivateMarket, name)
	return err
}

const insertMarket = `-- name: InsertMarket :one

INSERT INTO market (name,base_asset,quote_asset,base_asset_precision,
quote_asset_precision,tradable,strategy_type,base_price,quote_price, active) VALUES
($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING name, base_asset, quote_asset, base_asset_precision, quote_asset_precision, tradable, strategy_type, base_price, quote_price, active
`

type InsertMarketParams struct {
	Name                string
	BaseAsset           string
	QuoteAsset          string
	BaseAssetPrecision  int32
	QuoteAssetPrecision int32
	Tradable            bool
	StrategyType        int32
	BasePrice           float64
	QuotePrice          float64
	Active              bool
}

// * Market *
func (q *Queries) InsertMarket(ctx context.Context, arg InsertMarketParams) (Market, error) {
	row := q.db.QueryRow(ctx, insertMarket,
		arg.Name,
		arg.BaseAsset,
		arg.QuoteAsset,
		arg.BaseAssetPrecision,
		arg.QuoteAssetPrecision,
		arg.Tradable,
		arg.StrategyType,
		arg.BasePrice,
		arg.QuotePrice,
		arg.Active,
	)
	var i Market
	err := row.Scan(
		&i.Name,
		&i.BaseAsset,
		&i.QuoteAsset,
		&i.BaseAssetPrecision,
		&i.QuoteAssetPrecision,
		&i.Tradable,
		&i.StrategyType,
		&i.BasePrice,
		&i.QuotePrice,
		&i.Active,
	)
	return i, err
}

const insertMarketFee = `-- name: InsertMarketFee :one

INSERT INTO market_fee (base_asset_fee, quote_asset_fee, type, fk_market_name) VALUES
($1, $2, $3, $4) RETURNING id, base_asset_fee, quote_asset_fee, type, fk_market_name
`

type InsertMarketFeeParams struct {
	BaseAssetFee  int64
	QuoteAssetFee int64
	Type          string
	FkMarketName  string
}

// * MarketFee *
func (q *Queries) InsertMarketFee(ctx context.Context, arg InsertMarketFeeParams) (MarketFee, error) {
	row := q.db.QueryRow(ctx, insertMarketFee,
		arg.BaseAssetFee,
		arg.QuoteAssetFee,
		arg.Type,
		arg.FkMarketName,
	)
	var i MarketFee
	err := row.Scan(
		&i.ID,
		&i.BaseAssetFee,
		&i.QuoteAssetFee,
		&i.Type,
		&i.FkMarketName,
	)
	return i, err
}

const insertSwap = `-- name: InsertSwap :one

INSERT INTO swap (id, message, timestamp, type, fk_trade_id) VALUES
($1, $2, $3, $4, $5) RETURNING id, message, timestamp, type, fk_trade_id
`

type InsertSwapParams struct {
	ID        string
	Message   []byte
	Timestamp int64
	Type      string
	FkTradeID string
}

// * Swap *
func (q *Queries) InsertSwap(ctx context.Context, arg InsertSwapParams) (Swap, error) {
	row := q.db.QueryRow(ctx, insertSwap,
		arg.ID,
		arg.Message,
		arg.Timestamp,
		arg.Type,
		arg.FkTradeID,
	)
	var i Swap
	err := row.Scan(
		&i.ID,
		&i.Message,
		&i.Timestamp,
		&i.Type,
		&i.FkTradeID,
	)
	return i, err
}

const insertTrade = `-- name: InsertTrade :one

INSERT INTO trade (id, type, fee_asset, fee_amount, trader_pubkey, status_code,
status_failed, pset_base64, tx_id, tx_hex, expiry_time, settlement_time, base_price, quote_price,
fk_market_name) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
RETURNING id, type, fee_asset, fee_amount, trader_pubkey, status_code, status_failed, pset_base64, tx_id, tx_hex, expiry_time, settlement_time, base_price, quote_price, fk_market_name
`

type InsertTradeParams struct {
	ID             string
	Type           int32
	FeeAsset       string
	FeeAmount      int64
	TraderPubkey   []byte
	StatusCode     int32
	StatusFailed   bool
	PsetBase64     string
	TxID           sql.NullString
	TxHex          string
	ExpiryTime     sql.NullInt64
	SettlementTime sql.NullInt64
	BasePrice      sql.NullFloat64
	QuotePrice     sql.NullFloat64
	FkMarketName   string
}

// * Trade *
func (q *Queries) InsertTrade(ctx context.Context, arg InsertTradeParams) (Trade, error) {
	row := q.db.QueryRow(ctx, insertTrade,
		arg.ID,
		arg.Type,
		arg.FeeAsset,
		arg.FeeAmount,
		arg.TraderPubkey,
		arg.StatusCode,
		arg.StatusFailed,
		arg.PsetBase64,
		arg.TxID,
		arg.TxHex,
		arg.ExpiryTime,
		arg.SettlementTime,
		arg.BasePrice,
		arg.QuotePrice,
		arg.FkMarketName,
	)
	var i Trade
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.FeeAsset,
		&i.FeeAmount,
		&i.TraderPubkey,
		&i.StatusCode,
		&i.StatusFailed,
		&i.PsetBase64,
		&i.TxID,
		&i.TxHex,
		&i.ExpiryTime,
		&i.SettlementTime,
		&i.BasePrice,
		&i.QuotePrice,
		&i.FkMarketName,
	)
	return i, err
}

const insertTradeFee = `-- name: InsertTradeFee :one

INSERT INTO trade_fee (base_asset_fee, quote_asset_fee, type, fk_trade_id) VALUES
    ($1, $2, $3, $4) RETURNING id, base_asset_fee, quote_asset_fee, type, fk_trade_id
`

type InsertTradeFeeParams struct {
	BaseAssetFee  int64
	QuoteAssetFee int64
	Type          string
	FkTradeID     string
}

// * TradeFee *
func (q *Queries) InsertTradeFee(ctx context.Context, arg InsertTradeFeeParams) (TradeFee, error) {
	row := q.db.QueryRow(ctx, insertTradeFee,
		arg.BaseAssetFee,
		arg.QuoteAssetFee,
		arg.Type,
		arg.FkTradeID,
	)
	var i TradeFee
	err := row.Scan(
		&i.ID,
		&i.BaseAssetFee,
		&i.QuoteAssetFee,
		&i.Type,
		&i.FkTradeID,
	)
	return i, err
}

const insertTransaction = `-- name: InsertTransaction :one

INSERT INTO transaction (type, account_name, tx_id, timestamp) VALUES
($1, $2, $3, $4) RETURNING id, type, account_name, tx_id, timestamp
`

type InsertTransactionParams struct {
	Type        string
	AccountName string
	TxID        string
	Timestamp   int64
}

// * Transaction *
func (q *Queries) InsertTransaction(ctx context.Context, arg InsertTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, insertTransaction,
		arg.Type,
		arg.AccountName,
		arg.TxID,
		arg.Timestamp,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.AccountName,
		&i.TxID,
		&i.Timestamp,
	)
	return i, err
}

const insertTransactionAssetAmount = `-- name: InsertTransactionAssetAmount :one
INSERT INTO transaction_asset_amount (fk_transaction_id, asset, amount) VALUES
($1, $2, $3) RETURNING id, fk_transaction_id, asset, amount
`

type InsertTransactionAssetAmountParams struct {
	FkTransactionID int32
	Asset           string
	Amount          int64
}

func (q *Queries) InsertTransactionAssetAmount(ctx context.Context, arg InsertTransactionAssetAmountParams) (TransactionAssetAmount, error) {
	row := q.db.QueryRow(ctx, insertTransactionAssetAmount, arg.FkTransactionID, arg.Asset, arg.Amount)
	var i TransactionAssetAmount
	err := row.Scan(
		&i.ID,
		&i.FkTransactionID,
		&i.Asset,
		&i.Amount,
	)
	return i, err
}

const updateMarket = `-- name: UpdateMarket :one
UPDATE market SET base_asset_precision = $1, quote_asset_precision = $2,
tradable = $3, strategy_type = $4, base_price = $5, quote_price = $6 WHERE
name = $7 RETURNING name, base_asset, quote_asset, base_asset_precision, quote_asset_precision, tradable, strategy_type, base_price, quote_price, active
`

type UpdateMarketParams struct {
	BaseAssetPrecision  int32
	QuoteAssetPrecision int32
	Tradable            bool
	StrategyType        int32
	BasePrice           float64
	QuotePrice          float64
	Name                string
}

func (q *Queries) UpdateMarket(ctx context.Context, arg UpdateMarketParams) (Market, error) {
	row := q.db.QueryRow(ctx, updateMarket,
		arg.BaseAssetPrecision,
		arg.QuoteAssetPrecision,
		arg.Tradable,
		arg.StrategyType,
		arg.BasePrice,
		arg.QuotePrice,
		arg.Name,
	)
	var i Market
	err := row.Scan(
		&i.Name,
		&i.BaseAsset,
		&i.QuoteAsset,
		&i.BaseAssetPrecision,
		&i.QuoteAssetPrecision,
		&i.Tradable,
		&i.StrategyType,
		&i.BasePrice,
		&i.QuotePrice,
		&i.Active,
	)
	return i, err
}

const updateMarketFee = `-- name: UpdateMarketFee :one
UPDATE market_fee SET base_asset_fee = $1, quote_asset_fee = $2 WHERE
fk_market_name = $3 and type = $4 RETURNING id, base_asset_fee, quote_asset_fee, type, fk_market_name
`

type UpdateMarketFeeParams struct {
	BaseAssetFee  int64
	QuoteAssetFee int64
	FkMarketName  string
	Type          string
}

func (q *Queries) UpdateMarketFee(ctx context.Context, arg UpdateMarketFeeParams) (MarketFee, error) {
	row := q.db.QueryRow(ctx, updateMarketFee,
		arg.BaseAssetFee,
		arg.QuoteAssetFee,
		arg.FkMarketName,
		arg.Type,
	)
	var i MarketFee
	err := row.Scan(
		&i.ID,
		&i.BaseAssetFee,
		&i.QuoteAssetFee,
		&i.Type,
		&i.FkMarketName,
	)
	return i, err
}

const updateMarketPrice = `-- name: UpdateMarketPrice :one
UPDATE market SET base_price = $1, quote_price = $2 WHERE name = $3 RETURNING name, base_asset, quote_asset, base_asset_precision, quote_asset_precision, tradable, strategy_type, base_price, quote_price, active
`

type UpdateMarketPriceParams struct {
	BasePrice  float64
	QuotePrice float64
	Name       string
}

func (q *Queries) UpdateMarketPrice(ctx context.Context, arg UpdateMarketPriceParams) (Market, error) {
	row := q.db.QueryRow(ctx, updateMarketPrice, arg.BasePrice, arg.QuotePrice, arg.Name)
	var i Market
	err := row.Scan(
		&i.Name,
		&i.BaseAsset,
		&i.QuoteAsset,
		&i.BaseAssetPrecision,
		&i.QuoteAssetPrecision,
		&i.Tradable,
		&i.StrategyType,
		&i.BasePrice,
		&i.QuotePrice,
		&i.Active,
	)
	return i, err
}

const updateTrade = `-- name: UpdateTrade :one
UPDATE trade SET type = $1, fee_asset = $2, fee_amount = $3, trader_pubkey = $4,
status_code = $5, status_failed = $6, pset_base64 = $7, tx_id = $8, tx_hex = $9,
expiry_time = $10, settlement_time = $11 WHERE id = $12 RETURNING id, type, fee_asset, fee_amount, trader_pubkey, status_code, status_failed, pset_base64, tx_id, tx_hex, expiry_time, settlement_time, base_price, quote_price, fk_market_name
`

type UpdateTradeParams struct {
	Type           int32
	FeeAsset       string
	FeeAmount      int64
	TraderPubkey   []byte
	StatusCode     int32
	StatusFailed   bool
	PsetBase64     string
	TxID           sql.NullString
	TxHex          string
	ExpiryTime     sql.NullInt64
	SettlementTime sql.NullInt64
	ID             string
}

func (q *Queries) UpdateTrade(ctx context.Context, arg UpdateTradeParams) (Trade, error) {
	row := q.db.QueryRow(ctx, updateTrade,
		arg.Type,
		arg.FeeAsset,
		arg.FeeAmount,
		arg.TraderPubkey,
		arg.StatusCode,
		arg.StatusFailed,
		arg.PsetBase64,
		arg.TxID,
		arg.TxHex,
		arg.ExpiryTime,
		arg.SettlementTime,
		arg.ID,
	)
	var i Trade
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.FeeAsset,
		&i.FeeAmount,
		&i.TraderPubkey,
		&i.StatusCode,
		&i.StatusFailed,
		&i.PsetBase64,
		&i.TxID,
		&i.TxHex,
		&i.ExpiryTime,
		&i.SettlementTime,
		&i.BasePrice,
		&i.QuotePrice,
		&i.FkMarketName,
	)
	return i, err
}
