// Code generated by mockery v2.14.1. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	domain "github.com/tdex-network/tdex-daemon/internal/core/domain"
)

// MockSwapParser is an autogenerated mock type for the SwapParser type
type MockSwapParser struct {
	mock.Mock
}

// DeserializeAccept provides a mock function with given fields: msg
func (_m *MockSwapParser) DeserializeAccept(msg []byte) *domain.SwapAccept {
	ret := _m.Called(msg)

	var r0 *domain.SwapAccept
	if rf, ok := ret.Get(0).(func([]byte) *domain.SwapAccept); ok {
		r0 = rf(msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.SwapAccept)
		}
	}

	return r0
}

// DeserializeComplete provides a mock function with given fields: msg
func (_m *MockSwapParser) DeserializeComplete(msg []byte) *domain.SwapComplete {
	ret := _m.Called(msg)

	var r0 *domain.SwapComplete
	if rf, ok := ret.Get(0).(func([]byte) *domain.SwapComplete); ok {
		r0 = rf(msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.SwapComplete)
		}
	}

	return r0
}

// DeserializeFail provides a mock function with given fields: msg
func (_m *MockSwapParser) DeserializeFail(msg []byte) *domain.SwapFail {
	ret := _m.Called(msg)

	var r0 *domain.SwapFail
	if rf, ok := ret.Get(0).(func([]byte) *domain.SwapFail); ok {
		r0 = rf(msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.SwapFail)
		}
	}

	return r0
}

// DeserializeRequest provides a mock function with given fields: msg
func (_m *MockSwapParser) DeserializeRequest(msg []byte) *domain.SwapRequest {
	ret := _m.Called(msg)

	var r0 *domain.SwapRequest
	if rf, ok := ret.Get(0).(func([]byte) *domain.SwapRequest); ok {
		r0 = rf(msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.SwapRequest)
		}
	}

	return r0
}

// ParseSwapTransaction provides a mock function with given fields: tx
func (_m *MockSwapParser) ParseSwapTransaction(tx string) (*domain.SwapTransactionDetails, int) {
	ret := _m.Called(tx)

	var r0 *domain.SwapTransactionDetails
	if rf, ok := ret.Get(0).(func(string) *domain.SwapTransactionDetails); ok {
		r0 = rf(tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.SwapTransactionDetails)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(string) int); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Get(1).(int)
	}

	return r0, r1
}

// SerializeAccept provides a mock function with given fields: reqMsg, tx, unblindedIns
func (_m *MockSwapParser) SerializeAccept(reqMsg []byte, tx string, unblindedIns []domain.UnblindedInput) (string, []byte, int) {
	ret := _m.Called(reqMsg, tx, unblindedIns)

	var r0 string
	if rf, ok := ret.Get(0).(func([]byte, string, []domain.UnblindedInput) string); ok {
		r0 = rf(reqMsg, tx, unblindedIns)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 []byte
	if rf, ok := ret.Get(1).(func([]byte, string, []domain.UnblindedInput) []byte); ok {
		r1 = rf(reqMsg, tx, unblindedIns)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	var r2 int
	if rf, ok := ret.Get(2).(func([]byte, string, []domain.UnblindedInput) int); ok {
		r2 = rf(reqMsg, tx, unblindedIns)
	} else {
		r2 = ret.Get(2).(int)
	}

	return r0, r1, r2
}

// SerializeComplete provides a mock function with given fields: accMsg, tx
func (_m *MockSwapParser) SerializeComplete(accMsg []byte, tx string) (string, []byte, int) {
	ret := _m.Called(accMsg, tx)

	var r0 string
	if rf, ok := ret.Get(0).(func([]byte, string) string); ok {
		r0 = rf(accMsg, tx)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 []byte
	if rf, ok := ret.Get(1).(func([]byte, string) []byte); ok {
		r1 = rf(accMsg, tx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	var r2 int
	if rf, ok := ret.Get(2).(func([]byte, string) int); ok {
		r2 = rf(accMsg, tx)
	} else {
		r2 = ret.Get(2).(int)
	}

	return r0, r1, r2
}

// SerializeFail provides a mock function with given fields: id, code
func (_m *MockSwapParser) SerializeFail(id string, code int) (string, []byte) {
	ret := _m.Called(id, code)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, int) string); ok {
		r0 = rf(id, code)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 []byte
	if rf, ok := ret.Get(1).(func(string, int) []byte); ok {
		r1 = rf(id, code)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	return r0, r1
}

// SerializeRequest provides a mock function with given fields: r
func (_m *MockSwapParser) SerializeRequest(r domain.SwapRequest) ([]byte, int) {
	ret := _m.Called(r)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(domain.SwapRequest) []byte); ok {
		r0 = rf(r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(domain.SwapRequest) int); ok {
		r1 = rf(r)
	} else {
		r1 = ret.Get(1).(int)
	}

	return r0, r1
}

type mockConstructorTestingTNewMockSwapParser interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockSwapParser creates a new instance of MockSwapParser. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockSwapParser(t mockConstructorTestingTNewMockSwapParser) *MockSwapParser {
	mock := &MockSwapParser{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
