// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package operator

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// OperatorClient is the client API for Operator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OperatorClient interface {
	// Returns info about the internal wallet of the daemon.
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoReply, error)
	// Returns some new derived address(es) from the fee account.
	// This is only used to deposit some LBTC to subsidize blockchain fees.
	GetFeeAddress(ctx context.Context, in *GetFeeAddressRequest, opts ...grpc.CallOption) (*GetFeeAddressReply, error)
	// Returns the list of all derived addresses for the fee account.
	ListFeeAddresses(ctx context.Context, in *ListFeeAddressesRequest, opts ...grpc.CallOption) (*ListFeeAddressesReply, error)
	// Returns info about the balance of LBTC held in the fee account.
	GetFeeBalance(ctx context.Context, in *GetFeeBalanceRequest, opts ...grpc.CallOption) (*GetFeeBalanceReply, error)
	// Allows to provide transaction(s) outpoints of deposits made to fund the fee account.
	// The transaction(s) must be already included in blockchain.
	ClaimFeeDeposits(ctx context.Context, in *ClaimFeeDepositsRequest, opts ...grpc.CallOption) (*ClaimFeeDepositsReply, error)
	// Allows to withdraw funds from the fee account to a given address.
	WithdrawFee(ctx context.Context, in *WithdrawFeeRequest, opts ...grpc.CallOption) (*WithdrawFeeReply, error)
	// Creates a new market account in the daemon's wallet.
	NewMarket(ctx context.Context, in *NewMarketRequest, opts ...grpc.CallOption) (*NewMarketReply, error)
	// Returns some new derived address(es) for the given market.
	GetMarketAddress(ctx context.Context, in *GetMarketAddressRequest, opts ...grpc.CallOption) (*GetMarketAddressReply, error)
	// Returns the list of all derived addresses for the given market.
	ListMarketAddresses(ctx context.Context, in *ListMarketAddressesRequest, opts ...grpc.CallOption) (*ListMarketAddressesReply, error)
	// Returns info about the balance of the given market.
	GetMarketBalance(ctx context.Context, in *GetMarketBalanceRequest, opts ...grpc.CallOption) (*GetMarketBalanceReply, error)
	// Allows to provide transaction(s) outpoints of deposits made to fund a market.
	// The transaction(s) provided must be already included in blockchain.
	ClaimMarketDeposits(ctx context.Context, in *ClaimMarketDepositsRequest, opts ...grpc.CallOption) (*ClaimMarketDepositsReply, error)
	// Makes the given market tradable.
	OpenMarket(ctx context.Context, in *OpenMarketRequest, opts ...grpc.CallOption) (*OpenMarketReply, error)
	// Makes the given market NOT tradabale.
	CloseMarket(ctx context.Context, in *CloseMarketRequest, opts ...grpc.CallOption) (*CloseMarketReply, error)
	// Deletes a market.
	DropMarket(ctx context.Context, in *DropMarketRequest, opts ...grpc.CallOption) (*DropMarketReply, error)
	// Displays a report of the colected fees for the given market.
	GetMarketCollectedSwapFees(ctx context.Context, in *GetMarketCollectedSwapFeesRequest, opts ...grpc.CallOption) (*GetMarketCollectedSwapFeesReply, error)
	// Allows to withdraw funds from the given market to a given address.
	WithdrawMarket(ctx context.Context, in *WithdrawMarketRequest, opts ...grpc.CallOption) (*WithdrawMarketReply, error)
	// Changes the Liquidity Provider percentage fee for the given market.
	UpdateMarketPercentageFee(ctx context.Context, in *UpdateMarketPercentageFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error)
	// Changes the Liquidity provider fixed fees for the given market.
	UpdateMarketFixedFee(ctx context.Context, in *UpdateMarketFixedFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error)
	// Updates the price for the given market.
	UpdateMarketPrice(ctx context.Context, in *UpdateMarketPriceRequest, opts ...grpc.CallOption) (*UpdateMarketPriceReply, error)
	// Updates the current market making strategy, either using an automated
	// market making formula or a pluggable price feed.
	UpdateMarketStrategy(ctx context.Context, in *UpdateMarketStrategyRequest, opts ...grpc.CallOption) (*UpdateMarketStrategyReply, error)
	// Get extended details for each market either open, closed or to be funded.
	ListMarkets(ctx context.Context, in *ListMarketsRequest, opts ...grpc.CallOption) (*ListMarketsReply, error)
	// Returs all the trades processed by the daemon (ongoing, completed and
	// failed/rejected) or all those filtered by market.
	ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesReply, error)
	// Causes the daemon to re-sync the whole utxo set.
	ReloadUtxos(ctx context.Context, in *ReloadUtxosRequest, opts ...grpc.CallOption) (*ReloadUtxosReply, error)
	// Returns all the utxos, whether unspents, spents or locked.
	ListUtxos(ctx context.Context, in *ListUtxosRequest, opts ...grpc.CallOption) (*ListUtxosReply, error)
	// Adds a webhook registered for some kind of event.
	AddWebhook(ctx context.Context, in *AddWebhookRequest, opts ...grpc.CallOption) (*AddWebhookReply, error)
	// Removes some previously added webhook.
	RemoveWebhook(ctx context.Context, in *RemoveWebhookRequest, opts ...grpc.CallOption) (*RemoveWebhookReply, error)
	// Returns registered webhooks
	ListWebhooks(ctx context.Context, in *ListWebhooksRequest, opts ...grpc.CallOption) (*ListWebhooksReply, error)
	// Returns the list of all claimed deposits for the given account.
	ListDeposits(ctx context.Context, in *ListDepositsRequest, opts ...grpc.CallOption) (*ListDepositsReply, error)
	// Returns the list of all withdrawals made for the given account.
	ListWithdrawals(ctx context.Context, in *ListWithdrawalsRequest, opts ...grpc.CallOption) (*ListWithdrawalsReply, error)
}

type operatorClient struct {
	cc grpc.ClientConnInterface
}

func NewOperatorClient(cc grpc.ClientConnInterface) OperatorClient {
	return &operatorClient{cc}
}

func (c *operatorClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoReply, error) {
	out := new(GetInfoReply)
	err := c.cc.Invoke(ctx, "/Operator/GetInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetFeeAddress(ctx context.Context, in *GetFeeAddressRequest, opts ...grpc.CallOption) (*GetFeeAddressReply, error) {
	out := new(GetFeeAddressReply)
	err := c.cc.Invoke(ctx, "/Operator/GetFeeAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListFeeAddresses(ctx context.Context, in *ListFeeAddressesRequest, opts ...grpc.CallOption) (*ListFeeAddressesReply, error) {
	out := new(ListFeeAddressesReply)
	err := c.cc.Invoke(ctx, "/Operator/ListFeeAddresses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetFeeBalance(ctx context.Context, in *GetFeeBalanceRequest, opts ...grpc.CallOption) (*GetFeeBalanceReply, error) {
	out := new(GetFeeBalanceReply)
	err := c.cc.Invoke(ctx, "/Operator/GetFeeBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ClaimFeeDeposits(ctx context.Context, in *ClaimFeeDepositsRequest, opts ...grpc.CallOption) (*ClaimFeeDepositsReply, error) {
	out := new(ClaimFeeDepositsReply)
	err := c.cc.Invoke(ctx, "/Operator/ClaimFeeDeposits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) WithdrawFee(ctx context.Context, in *WithdrawFeeRequest, opts ...grpc.CallOption) (*WithdrawFeeReply, error) {
	out := new(WithdrawFeeReply)
	err := c.cc.Invoke(ctx, "/Operator/WithdrawFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) NewMarket(ctx context.Context, in *NewMarketRequest, opts ...grpc.CallOption) (*NewMarketReply, error) {
	out := new(NewMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/NewMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetMarketAddress(ctx context.Context, in *GetMarketAddressRequest, opts ...grpc.CallOption) (*GetMarketAddressReply, error) {
	out := new(GetMarketAddressReply)
	err := c.cc.Invoke(ctx, "/Operator/GetMarketAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListMarketAddresses(ctx context.Context, in *ListMarketAddressesRequest, opts ...grpc.CallOption) (*ListMarketAddressesReply, error) {
	out := new(ListMarketAddressesReply)
	err := c.cc.Invoke(ctx, "/Operator/ListMarketAddresses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetMarketBalance(ctx context.Context, in *GetMarketBalanceRequest, opts ...grpc.CallOption) (*GetMarketBalanceReply, error) {
	out := new(GetMarketBalanceReply)
	err := c.cc.Invoke(ctx, "/Operator/GetMarketBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ClaimMarketDeposits(ctx context.Context, in *ClaimMarketDepositsRequest, opts ...grpc.CallOption) (*ClaimMarketDepositsReply, error) {
	out := new(ClaimMarketDepositsReply)
	err := c.cc.Invoke(ctx, "/Operator/ClaimMarketDeposits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) OpenMarket(ctx context.Context, in *OpenMarketRequest, opts ...grpc.CallOption) (*OpenMarketReply, error) {
	out := new(OpenMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/OpenMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) CloseMarket(ctx context.Context, in *CloseMarketRequest, opts ...grpc.CallOption) (*CloseMarketReply, error) {
	out := new(CloseMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/CloseMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) DropMarket(ctx context.Context, in *DropMarketRequest, opts ...grpc.CallOption) (*DropMarketReply, error) {
	out := new(DropMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/DropMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetMarketCollectedSwapFees(ctx context.Context, in *GetMarketCollectedSwapFeesRequest, opts ...grpc.CallOption) (*GetMarketCollectedSwapFeesReply, error) {
	out := new(GetMarketCollectedSwapFeesReply)
	err := c.cc.Invoke(ctx, "/Operator/GetMarketCollectedSwapFees", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) WithdrawMarket(ctx context.Context, in *WithdrawMarketRequest, opts ...grpc.CallOption) (*WithdrawMarketReply, error) {
	out := new(WithdrawMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/WithdrawMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) UpdateMarketPercentageFee(ctx context.Context, in *UpdateMarketPercentageFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error) {
	out := new(UpdateMarketFeeReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketPercentageFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) UpdateMarketFixedFee(ctx context.Context, in *UpdateMarketFixedFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error) {
	out := new(UpdateMarketFeeReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketFixedFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) UpdateMarketPrice(ctx context.Context, in *UpdateMarketPriceRequest, opts ...grpc.CallOption) (*UpdateMarketPriceReply, error) {
	out := new(UpdateMarketPriceReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) UpdateMarketStrategy(ctx context.Context, in *UpdateMarketStrategyRequest, opts ...grpc.CallOption) (*UpdateMarketStrategyReply, error) {
	out := new(UpdateMarketStrategyReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketStrategy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListMarkets(ctx context.Context, in *ListMarketsRequest, opts ...grpc.CallOption) (*ListMarketsReply, error) {
	out := new(ListMarketsReply)
	err := c.cc.Invoke(ctx, "/Operator/ListMarkets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesReply, error) {
	out := new(ListTradesReply)
	err := c.cc.Invoke(ctx, "/Operator/ListTrades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ReloadUtxos(ctx context.Context, in *ReloadUtxosRequest, opts ...grpc.CallOption) (*ReloadUtxosReply, error) {
	out := new(ReloadUtxosReply)
	err := c.cc.Invoke(ctx, "/Operator/ReloadUtxos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListUtxos(ctx context.Context, in *ListUtxosRequest, opts ...grpc.CallOption) (*ListUtxosReply, error) {
	out := new(ListUtxosReply)
	err := c.cc.Invoke(ctx, "/Operator/ListUtxos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) AddWebhook(ctx context.Context, in *AddWebhookRequest, opts ...grpc.CallOption) (*AddWebhookReply, error) {
	out := new(AddWebhookReply)
	err := c.cc.Invoke(ctx, "/Operator/AddWebhook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) RemoveWebhook(ctx context.Context, in *RemoveWebhookRequest, opts ...grpc.CallOption) (*RemoveWebhookReply, error) {
	out := new(RemoveWebhookReply)
	err := c.cc.Invoke(ctx, "/Operator/RemoveWebhook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListWebhooks(ctx context.Context, in *ListWebhooksRequest, opts ...grpc.CallOption) (*ListWebhooksReply, error) {
	out := new(ListWebhooksReply)
	err := c.cc.Invoke(ctx, "/Operator/ListWebhooks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListDeposits(ctx context.Context, in *ListDepositsRequest, opts ...grpc.CallOption) (*ListDepositsReply, error) {
	out := new(ListDepositsReply)
	err := c.cc.Invoke(ctx, "/Operator/ListDeposits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListWithdrawals(ctx context.Context, in *ListWithdrawalsRequest, opts ...grpc.CallOption) (*ListWithdrawalsReply, error) {
	out := new(ListWithdrawalsReply)
	err := c.cc.Invoke(ctx, "/Operator/ListWithdrawals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OperatorServer is the server API for Operator service.
// All implementations must embed UnimplementedOperatorServer
// for forward compatibility
type OperatorServer interface {
	// Returns info about the internal wallet of the daemon.
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoReply, error)
	// Returns some new derived address(es) from the fee account.
	// This is only used to deposit some LBTC to subsidize blockchain fees.
	GetFeeAddress(context.Context, *GetFeeAddressRequest) (*GetFeeAddressReply, error)
	// Returns the list of all derived addresses for the fee account.
	ListFeeAddresses(context.Context, *ListFeeAddressesRequest) (*ListFeeAddressesReply, error)
	// Returns info about the balance of LBTC held in the fee account.
	GetFeeBalance(context.Context, *GetFeeBalanceRequest) (*GetFeeBalanceReply, error)
	// Allows to provide transaction(s) outpoints of deposits made to fund the fee account.
	// The transaction(s) must be already included in blockchain.
	ClaimFeeDeposits(context.Context, *ClaimFeeDepositsRequest) (*ClaimFeeDepositsReply, error)
	// Allows to withdraw funds from the fee account to a given address.
	WithdrawFee(context.Context, *WithdrawFeeRequest) (*WithdrawFeeReply, error)
	// Creates a new market account in the daemon's wallet.
	NewMarket(context.Context, *NewMarketRequest) (*NewMarketReply, error)
	// Returns some new derived address(es) for the given market.
	GetMarketAddress(context.Context, *GetMarketAddressRequest) (*GetMarketAddressReply, error)
	// Returns the list of all derived addresses for the given market.
	ListMarketAddresses(context.Context, *ListMarketAddressesRequest) (*ListMarketAddressesReply, error)
	// Returns info about the balance of the given market.
	GetMarketBalance(context.Context, *GetMarketBalanceRequest) (*GetMarketBalanceReply, error)
	// Allows to provide transaction(s) outpoints of deposits made to fund a market.
	// The transaction(s) provided must be already included in blockchain.
	ClaimMarketDeposits(context.Context, *ClaimMarketDepositsRequest) (*ClaimMarketDepositsReply, error)
	// Makes the given market tradable.
	OpenMarket(context.Context, *OpenMarketRequest) (*OpenMarketReply, error)
	// Makes the given market NOT tradabale.
	CloseMarket(context.Context, *CloseMarketRequest) (*CloseMarketReply, error)
	// Deletes a market.
	DropMarket(context.Context, *DropMarketRequest) (*DropMarketReply, error)
	// Displays a report of the colected fees for the given market.
	GetMarketCollectedSwapFees(context.Context, *GetMarketCollectedSwapFeesRequest) (*GetMarketCollectedSwapFeesReply, error)
	// Allows to withdraw funds from the given market to a given address.
	WithdrawMarket(context.Context, *WithdrawMarketRequest) (*WithdrawMarketReply, error)
	// Changes the Liquidity Provider percentage fee for the given market.
	UpdateMarketPercentageFee(context.Context, *UpdateMarketPercentageFeeRequest) (*UpdateMarketFeeReply, error)
	// Changes the Liquidity provider fixed fees for the given market.
	UpdateMarketFixedFee(context.Context, *UpdateMarketFixedFeeRequest) (*UpdateMarketFeeReply, error)
	// Updates the price for the given market.
	UpdateMarketPrice(context.Context, *UpdateMarketPriceRequest) (*UpdateMarketPriceReply, error)
	// Updates the current market making strategy, either using an automated
	// market making formula or a pluggable price feed.
	UpdateMarketStrategy(context.Context, *UpdateMarketStrategyRequest) (*UpdateMarketStrategyReply, error)
	// Get extended details for each market either open, closed or to be funded.
	ListMarkets(context.Context, *ListMarketsRequest) (*ListMarketsReply, error)
	// Returs all the trades processed by the daemon (ongoing, completed and
	// failed/rejected) or all those filtered by market.
	ListTrades(context.Context, *ListTradesRequest) (*ListTradesReply, error)
	// Causes the daemon to re-sync the whole utxo set.
	ReloadUtxos(context.Context, *ReloadUtxosRequest) (*ReloadUtxosReply, error)
	// Returns all the utxos, whether unspents, spents or locked.
	ListUtxos(context.Context, *ListUtxosRequest) (*ListUtxosReply, error)
	// Adds a webhook registered for some kind of event.
	AddWebhook(context.Context, *AddWebhookRequest) (*AddWebhookReply, error)
	// Removes some previously added webhook.
	RemoveWebhook(context.Context, *RemoveWebhookRequest) (*RemoveWebhookReply, error)
	// Returns registered webhooks
	ListWebhooks(context.Context, *ListWebhooksRequest) (*ListWebhooksReply, error)
	// Returns the list of all claimed deposits for the given account.
	ListDeposits(context.Context, *ListDepositsRequest) (*ListDepositsReply, error)
	// Returns the list of all withdrawals made for the given account.
	ListWithdrawals(context.Context, *ListWithdrawalsRequest) (*ListWithdrawalsReply, error)
	mustEmbedUnimplementedOperatorServer()
}

// UnimplementedOperatorServer must be embedded to have forward compatible implementations.
type UnimplementedOperatorServer struct {
}

func (UnimplementedOperatorServer) GetInfo(context.Context, *GetInfoRequest) (*GetInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfo not implemented")
}
func (UnimplementedOperatorServer) GetFeeAddress(context.Context, *GetFeeAddressRequest) (*GetFeeAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeeAddress not implemented")
}
func (UnimplementedOperatorServer) ListFeeAddresses(context.Context, *ListFeeAddressesRequest) (*ListFeeAddressesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFeeAddresses not implemented")
}
func (UnimplementedOperatorServer) GetFeeBalance(context.Context, *GetFeeBalanceRequest) (*GetFeeBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeeBalance not implemented")
}
func (UnimplementedOperatorServer) ClaimFeeDeposits(context.Context, *ClaimFeeDepositsRequest) (*ClaimFeeDepositsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimFeeDeposits not implemented")
}
func (UnimplementedOperatorServer) WithdrawFee(context.Context, *WithdrawFeeRequest) (*WithdrawFeeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawFee not implemented")
}
func (UnimplementedOperatorServer) NewMarket(context.Context, *NewMarketRequest) (*NewMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewMarket not implemented")
}
func (UnimplementedOperatorServer) GetMarketAddress(context.Context, *GetMarketAddressRequest) (*GetMarketAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarketAddress not implemented")
}
func (UnimplementedOperatorServer) ListMarketAddresses(context.Context, *ListMarketAddressesRequest) (*ListMarketAddressesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMarketAddresses not implemented")
}
func (UnimplementedOperatorServer) GetMarketBalance(context.Context, *GetMarketBalanceRequest) (*GetMarketBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarketBalance not implemented")
}
func (UnimplementedOperatorServer) ClaimMarketDeposits(context.Context, *ClaimMarketDepositsRequest) (*ClaimMarketDepositsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimMarketDeposits not implemented")
}
func (UnimplementedOperatorServer) OpenMarket(context.Context, *OpenMarketRequest) (*OpenMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenMarket not implemented")
}
func (UnimplementedOperatorServer) CloseMarket(context.Context, *CloseMarketRequest) (*CloseMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseMarket not implemented")
}
func (UnimplementedOperatorServer) DropMarket(context.Context, *DropMarketRequest) (*DropMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropMarket not implemented")
}
func (UnimplementedOperatorServer) GetMarketCollectedSwapFees(context.Context, *GetMarketCollectedSwapFeesRequest) (*GetMarketCollectedSwapFeesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarketCollectedSwapFees not implemented")
}
func (UnimplementedOperatorServer) WithdrawMarket(context.Context, *WithdrawMarketRequest) (*WithdrawMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawMarket not implemented")
}
func (UnimplementedOperatorServer) UpdateMarketPercentageFee(context.Context, *UpdateMarketPercentageFeeRequest) (*UpdateMarketFeeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketPercentageFee not implemented")
}
func (UnimplementedOperatorServer) UpdateMarketFixedFee(context.Context, *UpdateMarketFixedFeeRequest) (*UpdateMarketFeeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketFixedFee not implemented")
}
func (UnimplementedOperatorServer) UpdateMarketPrice(context.Context, *UpdateMarketPriceRequest) (*UpdateMarketPriceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketPrice not implemented")
}
func (UnimplementedOperatorServer) UpdateMarketStrategy(context.Context, *UpdateMarketStrategyRequest) (*UpdateMarketStrategyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketStrategy not implemented")
}
func (UnimplementedOperatorServer) ListMarkets(context.Context, *ListMarketsRequest) (*ListMarketsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMarkets not implemented")
}
func (UnimplementedOperatorServer) ListTrades(context.Context, *ListTradesRequest) (*ListTradesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTrades not implemented")
}
func (UnimplementedOperatorServer) ReloadUtxos(context.Context, *ReloadUtxosRequest) (*ReloadUtxosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReloadUtxos not implemented")
}
func (UnimplementedOperatorServer) ListUtxos(context.Context, *ListUtxosRequest) (*ListUtxosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUtxos not implemented")
}
func (UnimplementedOperatorServer) AddWebhook(context.Context, *AddWebhookRequest) (*AddWebhookReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddWebhook not implemented")
}
func (UnimplementedOperatorServer) RemoveWebhook(context.Context, *RemoveWebhookRequest) (*RemoveWebhookReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveWebhook not implemented")
}
func (UnimplementedOperatorServer) ListWebhooks(context.Context, *ListWebhooksRequest) (*ListWebhooksReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWebhooks not implemented")
}
func (UnimplementedOperatorServer) ListDeposits(context.Context, *ListDepositsRequest) (*ListDepositsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDeposits not implemented")
}
func (UnimplementedOperatorServer) ListWithdrawals(context.Context, *ListWithdrawalsRequest) (*ListWithdrawalsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWithdrawals not implemented")
}
func (UnimplementedOperatorServer) mustEmbedUnimplementedOperatorServer() {}

// UnsafeOperatorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OperatorServer will
// result in compilation errors.
type UnsafeOperatorServer interface {
	mustEmbedUnimplementedOperatorServer()
}

func RegisterOperatorServer(s grpc.ServiceRegistrar, srv OperatorServer) {
	s.RegisterService(&Operator_ServiceDesc, srv)
}

func _Operator_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetFeeAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeeAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetFeeAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetFeeAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetFeeAddress(ctx, req.(*GetFeeAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListFeeAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFeeAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListFeeAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListFeeAddresses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListFeeAddresses(ctx, req.(*ListFeeAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetFeeBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeeBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetFeeBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetFeeBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetFeeBalance(ctx, req.(*GetFeeBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ClaimFeeDeposits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimFeeDepositsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ClaimFeeDeposits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ClaimFeeDeposits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ClaimFeeDeposits(ctx, req.(*ClaimFeeDepositsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_WithdrawFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).WithdrawFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/WithdrawFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).WithdrawFee(ctx, req.(*WithdrawFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_NewMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).NewMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/NewMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).NewMarket(ctx, req.(*NewMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetMarketAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarketAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetMarketAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetMarketAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetMarketAddress(ctx, req.(*GetMarketAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListMarketAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMarketAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListMarketAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListMarketAddresses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListMarketAddresses(ctx, req.(*ListMarketAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetMarketBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarketBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetMarketBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetMarketBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetMarketBalance(ctx, req.(*GetMarketBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ClaimMarketDeposits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimMarketDepositsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ClaimMarketDeposits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ClaimMarketDeposits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ClaimMarketDeposits(ctx, req.(*ClaimMarketDepositsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_OpenMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).OpenMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/OpenMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).OpenMarket(ctx, req.(*OpenMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_CloseMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).CloseMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/CloseMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).CloseMarket(ctx, req.(*CloseMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_DropMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).DropMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/DropMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).DropMarket(ctx, req.(*DropMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetMarketCollectedSwapFees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarketCollectedSwapFeesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetMarketCollectedSwapFees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetMarketCollectedSwapFees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetMarketCollectedSwapFees(ctx, req.(*GetMarketCollectedSwapFeesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_WithdrawMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).WithdrawMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/WithdrawMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).WithdrawMarket(ctx, req.(*WithdrawMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_UpdateMarketPercentageFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketPercentageFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).UpdateMarketPercentageFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/UpdateMarketPercentageFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).UpdateMarketPercentageFee(ctx, req.(*UpdateMarketPercentageFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_UpdateMarketFixedFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketFixedFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).UpdateMarketFixedFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/UpdateMarketFixedFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).UpdateMarketFixedFee(ctx, req.(*UpdateMarketFixedFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_UpdateMarketPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).UpdateMarketPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/UpdateMarketPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).UpdateMarketPrice(ctx, req.(*UpdateMarketPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_UpdateMarketStrategy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketStrategyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).UpdateMarketStrategy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/UpdateMarketStrategy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).UpdateMarketStrategy(ctx, req.(*UpdateMarketStrategyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListMarkets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMarketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListMarkets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListMarkets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListMarkets(ctx, req.(*ListMarketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTradesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListTrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListTrades(ctx, req.(*ListTradesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ReloadUtxos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReloadUtxosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ReloadUtxos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ReloadUtxos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ReloadUtxos(ctx, req.(*ReloadUtxosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListUtxos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUtxosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListUtxos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListUtxos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListUtxos(ctx, req.(*ListUtxosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_AddWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).AddWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/AddWebhook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).AddWebhook(ctx, req.(*AddWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_RemoveWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).RemoveWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/RemoveWebhook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).RemoveWebhook(ctx, req.(*RemoveWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListWebhooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWebhooksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListWebhooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListWebhooks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListWebhooks(ctx, req.(*ListWebhooksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListDeposits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDepositsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListDeposits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListDeposits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListDeposits(ctx, req.(*ListDepositsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListWithdrawals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWithdrawalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListWithdrawals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListWithdrawals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListWithdrawals(ctx, req.(*ListWithdrawalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Operator_ServiceDesc is the grpc.ServiceDesc for Operator service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Operator_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Operator",
	HandlerType: (*OperatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInfo",
			Handler:    _Operator_GetInfo_Handler,
		},
		{
			MethodName: "GetFeeAddress",
			Handler:    _Operator_GetFeeAddress_Handler,
		},
		{
			MethodName: "ListFeeAddresses",
			Handler:    _Operator_ListFeeAddresses_Handler,
		},
		{
			MethodName: "GetFeeBalance",
			Handler:    _Operator_GetFeeBalance_Handler,
		},
		{
			MethodName: "ClaimFeeDeposits",
			Handler:    _Operator_ClaimFeeDeposits_Handler,
		},
		{
			MethodName: "WithdrawFee",
			Handler:    _Operator_WithdrawFee_Handler,
		},
		{
			MethodName: "NewMarket",
			Handler:    _Operator_NewMarket_Handler,
		},
		{
			MethodName: "GetMarketAddress",
			Handler:    _Operator_GetMarketAddress_Handler,
		},
		{
			MethodName: "ListMarketAddresses",
			Handler:    _Operator_ListMarketAddresses_Handler,
		},
		{
			MethodName: "GetMarketBalance",
			Handler:    _Operator_GetMarketBalance_Handler,
		},
		{
			MethodName: "ClaimMarketDeposits",
			Handler:    _Operator_ClaimMarketDeposits_Handler,
		},
		{
			MethodName: "OpenMarket",
			Handler:    _Operator_OpenMarket_Handler,
		},
		{
			MethodName: "CloseMarket",
			Handler:    _Operator_CloseMarket_Handler,
		},
		{
			MethodName: "DropMarket",
			Handler:    _Operator_DropMarket_Handler,
		},
		{
			MethodName: "GetMarketCollectedSwapFees",
			Handler:    _Operator_GetMarketCollectedSwapFees_Handler,
		},
		{
			MethodName: "WithdrawMarket",
			Handler:    _Operator_WithdrawMarket_Handler,
		},
		{
			MethodName: "UpdateMarketPercentageFee",
			Handler:    _Operator_UpdateMarketPercentageFee_Handler,
		},
		{
			MethodName: "UpdateMarketFixedFee",
			Handler:    _Operator_UpdateMarketFixedFee_Handler,
		},
		{
			MethodName: "UpdateMarketPrice",
			Handler:    _Operator_UpdateMarketPrice_Handler,
		},
		{
			MethodName: "UpdateMarketStrategy",
			Handler:    _Operator_UpdateMarketStrategy_Handler,
		},
		{
			MethodName: "ListMarkets",
			Handler:    _Operator_ListMarkets_Handler,
		},
		{
			MethodName: "ListTrades",
			Handler:    _Operator_ListTrades_Handler,
		},
		{
			MethodName: "ReloadUtxos",
			Handler:    _Operator_ReloadUtxos_Handler,
		},
		{
			MethodName: "ListUtxos",
			Handler:    _Operator_ListUtxos_Handler,
		},
		{
			MethodName: "AddWebhook",
			Handler:    _Operator_AddWebhook_Handler,
		},
		{
			MethodName: "RemoveWebhook",
			Handler:    _Operator_RemoveWebhook_Handler,
		},
		{
			MethodName: "ListWebhooks",
			Handler:    _Operator_ListWebhooks_Handler,
		},
		{
			MethodName: "ListDeposits",
			Handler:    _Operator_ListDeposits_Handler,
		},
		{
			MethodName: "ListWithdrawals",
			Handler:    _Operator_ListWithdrawals_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "operator.proto",
}
