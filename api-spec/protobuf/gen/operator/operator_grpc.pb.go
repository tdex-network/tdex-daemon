// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.17.3
// source: operator.proto

package operator

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// OperatorClient is the client API for Operator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OperatorClient interface {
	// Returns info about the internal wallet of the daemon.
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoReply, error)
	// Returns some new derived address(es) from the fee account.
	// This is only used to deposit some LBTC to subsidize blockchain fees.
	GetFeeAddress(ctx context.Context, in *GetFeeAddressRequest, opts ...grpc.CallOption) (*GetFeeAddressReply, error)
	// Returns the list of all derived addresses for the fee account.
	ListFeeAddresses(ctx context.Context, in *ListFeeAddressesRequest, opts ...grpc.CallOption) (*ListFeeAddressesReply, error)
	// Returns info about the balance of LBTC held in the fee account.
	GetFeeBalance(ctx context.Context, in *GetFeeBalanceRequest, opts ...grpc.CallOption) (*GetFeeBalanceReply, error)
	// Allows to provide transaction(s) outpoints of deposits made to fund the fee account.
	// The transaction(s) must be already included in blockchain.
	ClaimFeeDeposits(ctx context.Context, in *ClaimFeeDepositsRequest, opts ...grpc.CallOption) (*ClaimFeeDepositsReply, error)
	// Allows to withdraw funds from the fee account to a given address.
	WithdrawFee(ctx context.Context, in *WithdrawFeeRequest, opts ...grpc.CallOption) (*WithdrawFeeReply, error)
	// Creates a new market account in the daemon's wallet.
	NewMarket(ctx context.Context, in *NewMarketRequest, opts ...grpc.CallOption) (*NewMarketReply, error)
	GetMarketInfo(ctx context.Context, in *GetMarketInfoRequest, opts ...grpc.CallOption) (*GetMarketInfoReply, error)
	// Returns some new derived address(es) for the given market.
	GetMarketAddress(ctx context.Context, in *GetMarketAddressRequest, opts ...grpc.CallOption) (*GetMarketAddressReply, error)
	// Returns the list of all derived addresses for the given market.
	ListMarketAddresses(ctx context.Context, in *ListMarketAddressesRequest, opts ...grpc.CallOption) (*ListMarketAddressesReply, error)
	// Returns info about the balance of the given market.
	GetMarketBalance(ctx context.Context, in *GetMarketBalanceRequest, opts ...grpc.CallOption) (*GetMarketBalanceReply, error)
	// Allows to provide transaction(s) outpoints of deposits made to fund a market.
	// The transaction(s) provided must be already included in blockchain.
	ClaimMarketDeposits(ctx context.Context, in *ClaimMarketDepositsRequest, opts ...grpc.CallOption) (*ClaimMarketDepositsReply, error)
	// Makes the given market tradable.
	OpenMarket(ctx context.Context, in *OpenMarketRequest, opts ...grpc.CallOption) (*OpenMarketReply, error)
	// Makes the given market NOT tradabale.
	CloseMarket(ctx context.Context, in *CloseMarketRequest, opts ...grpc.CallOption) (*CloseMarketReply, error)
	// Deletes a market.
	DropMarket(ctx context.Context, in *DropMarketRequest, opts ...grpc.CallOption) (*DropMarketReply, error)
	// Displays a report of the colected fees for the given market.
	GetMarketCollectedSwapFees(ctx context.Context, in *GetMarketCollectedSwapFeesRequest, opts ...grpc.CallOption) (*GetMarketCollectedSwapFeesReply, error)
	// Allows to withdraw funds from the given market to a given address.
	WithdrawMarket(ctx context.Context, in *WithdrawMarketRequest, opts ...grpc.CallOption) (*WithdrawMarketReply, error)
	// Changes the Liquidity Provider percentage fee for the given market.
	UpdateMarketPercentageFee(ctx context.Context, in *UpdateMarketPercentageFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error)
	// Changes the Liquidity provider fixed fees for the given market.
	UpdateMarketFixedFee(ctx context.Context, in *UpdateMarketFixedFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error)
	// Updates the price for the given market.
	UpdateMarketPrice(ctx context.Context, in *UpdateMarketPriceRequest, opts ...grpc.CallOption) (*UpdateMarketPriceReply, error)
	// Updates the current market making strategy, either using an automated
	// market making formula or a pluggable price feed.
	UpdateMarketStrategy(ctx context.Context, in *UpdateMarketStrategyRequest, opts ...grpc.CallOption) (*UpdateMarketStrategyReply, error)
	// Returns some new derived address(es) for the fee fragmenter account.
	GetFeeFragmenterAddress(ctx context.Context, in *GetFeeFragmenterAddressRequest, opts ...grpc.CallOption) (*GetFeeFragmenterAddressReply, error)
	// Returns the list of all derived addresses for the fee fragmenter account.
	ListFeeFragmenterAddresses(ctx context.Context, in *ListFeeFragmenterAddressesRequest, opts ...grpc.CallOption) (*ListFeeFragmenterAddressesReply, error)
	// Returns info about the balance of the fee fragmenter account.
	GetFeeFragmenterBalance(ctx context.Context, in *GetFeeFragmenterBalanceRequest, opts ...grpc.CallOption) (*GetFeeFragmenterBalanceReply, error)
	// Splits the funds sent to the fee fragmenter account into multiple
	// fragments that then becomes deposits of the Fee account.
	FeeFragmenterSplitFunds(ctx context.Context, in *FeeFragmenterSplitFundsRequest, opts ...grpc.CallOption) (Operator_FeeFragmenterSplitFundsClient, error)
	// Allows to withdraw funds from the fee fragmenter account to a given address.
	WithdrawFeeFragmenter(ctx context.Context, in *WithdrawFeeFragmenterRequest, opts ...grpc.CallOption) (*WithdrawFeeFragmenterReply, error)
	// Returns some new derived address(es) for the market fragmenter account.
	GetMarketFragmenterAddress(ctx context.Context, in *GetMarketFragmenterAddressRequest, opts ...grpc.CallOption) (*GetMarketFragmenterAddressReply, error)
	// Returns the list of all derived addresses for the market fragmenter account.
	ListMarketFragmenterAddresses(ctx context.Context, in *ListMarketFragmenterAddressesRequest, opts ...grpc.CallOption) (*ListMarketFragmenterAddressesReply, error)
	// Returns info about the balance of the market fragmenter account.
	GetMarketFragmenterBalance(ctx context.Context, in *GetMarketFragmenterBalanceRequest, opts ...grpc.CallOption) (*GetMarketFragmenterBalanceReply, error)
	// Splits the funds sent to the market fragmenter account into multiple
	// fragments that then becomes deposits of the given market.
	MarketFragmenterSplitFunds(ctx context.Context, in *MarketFragmenterSplitFundsRequest, opts ...grpc.CallOption) (Operator_MarketFragmenterSplitFundsClient, error)
	// Allows to withdraw funds from the market fragmenter account to a given address.
	WithdrawMarketFragmenter(ctx context.Context, in *WithdrawMarketFragmenterRequest, opts ...grpc.CallOption) (*WithdrawMarketFragmenterReply, error)
	// Get extended details for each market either open, closed or to be funded.
	ListMarkets(ctx context.Context, in *ListMarketsRequest, opts ...grpc.CallOption) (*ListMarketsReply, error)
	// Returs all the trades processed by the daemon (ongoing, completed and
	// failed/rejected) or all those filtered by market.
	ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesReply, error)
	// Causes the daemon to re-sync the whole utxo set.
	ReloadUtxos(ctx context.Context, in *ReloadUtxosRequest, opts ...grpc.CallOption) (*ReloadUtxosReply, error)
	// Returns all the utxos, whether unspents, spents or locked.
	ListUtxos(ctx context.Context, in *ListUtxosRequest, opts ...grpc.CallOption) (*ListUtxosReply, error)
	// Adds a webhook registered for some kind of event.
	AddWebhook(ctx context.Context, in *AddWebhookRequest, opts ...grpc.CallOption) (*AddWebhookReply, error)
	// Removes some previously added webhook.
	RemoveWebhook(ctx context.Context, in *RemoveWebhookRequest, opts ...grpc.CallOption) (*RemoveWebhookReply, error)
	// Returns registered webhooks
	ListWebhooks(ctx context.Context, in *ListWebhooksRequest, opts ...grpc.CallOption) (*ListWebhooksReply, error)
	// Returns the list of all claimed deposits for the given account.
	ListDeposits(ctx context.Context, in *ListDepositsRequest, opts ...grpc.CallOption) (*ListDepositsReply, error)
	// Returns the list of all withdrawals made for the given account.
	ListWithdrawals(ctx context.Context, in *ListWithdrawalsRequest, opts ...grpc.CallOption) (*ListWithdrawalsReply, error)
}

type operatorClient struct {
	cc grpc.ClientConnInterface
}

func NewOperatorClient(cc grpc.ClientConnInterface) OperatorClient {
	return &operatorClient{cc}
}

func (c *operatorClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoReply, error) {
	out := new(GetInfoReply)
	err := c.cc.Invoke(ctx, "/Operator/GetInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetFeeAddress(ctx context.Context, in *GetFeeAddressRequest, opts ...grpc.CallOption) (*GetFeeAddressReply, error) {
	out := new(GetFeeAddressReply)
	err := c.cc.Invoke(ctx, "/Operator/GetFeeAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListFeeAddresses(ctx context.Context, in *ListFeeAddressesRequest, opts ...grpc.CallOption) (*ListFeeAddressesReply, error) {
	out := new(ListFeeAddressesReply)
	err := c.cc.Invoke(ctx, "/Operator/ListFeeAddresses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetFeeBalance(ctx context.Context, in *GetFeeBalanceRequest, opts ...grpc.CallOption) (*GetFeeBalanceReply, error) {
	out := new(GetFeeBalanceReply)
	err := c.cc.Invoke(ctx, "/Operator/GetFeeBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ClaimFeeDeposits(ctx context.Context, in *ClaimFeeDepositsRequest, opts ...grpc.CallOption) (*ClaimFeeDepositsReply, error) {
	out := new(ClaimFeeDepositsReply)
	err := c.cc.Invoke(ctx, "/Operator/ClaimFeeDeposits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) WithdrawFee(ctx context.Context, in *WithdrawFeeRequest, opts ...grpc.CallOption) (*WithdrawFeeReply, error) {
	out := new(WithdrawFeeReply)
	err := c.cc.Invoke(ctx, "/Operator/WithdrawFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) NewMarket(ctx context.Context, in *NewMarketRequest, opts ...grpc.CallOption) (*NewMarketReply, error) {
	out := new(NewMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/NewMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetMarketInfo(ctx context.Context, in *GetMarketInfoRequest, opts ...grpc.CallOption) (*GetMarketInfoReply, error) {
	out := new(GetMarketInfoReply)
	err := c.cc.Invoke(ctx, "/Operator/GetMarketInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetMarketAddress(ctx context.Context, in *GetMarketAddressRequest, opts ...grpc.CallOption) (*GetMarketAddressReply, error) {
	out := new(GetMarketAddressReply)
	err := c.cc.Invoke(ctx, "/Operator/GetMarketAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListMarketAddresses(ctx context.Context, in *ListMarketAddressesRequest, opts ...grpc.CallOption) (*ListMarketAddressesReply, error) {
	out := new(ListMarketAddressesReply)
	err := c.cc.Invoke(ctx, "/Operator/ListMarketAddresses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetMarketBalance(ctx context.Context, in *GetMarketBalanceRequest, opts ...grpc.CallOption) (*GetMarketBalanceReply, error) {
	out := new(GetMarketBalanceReply)
	err := c.cc.Invoke(ctx, "/Operator/GetMarketBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ClaimMarketDeposits(ctx context.Context, in *ClaimMarketDepositsRequest, opts ...grpc.CallOption) (*ClaimMarketDepositsReply, error) {
	out := new(ClaimMarketDepositsReply)
	err := c.cc.Invoke(ctx, "/Operator/ClaimMarketDeposits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) OpenMarket(ctx context.Context, in *OpenMarketRequest, opts ...grpc.CallOption) (*OpenMarketReply, error) {
	out := new(OpenMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/OpenMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) CloseMarket(ctx context.Context, in *CloseMarketRequest, opts ...grpc.CallOption) (*CloseMarketReply, error) {
	out := new(CloseMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/CloseMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) DropMarket(ctx context.Context, in *DropMarketRequest, opts ...grpc.CallOption) (*DropMarketReply, error) {
	out := new(DropMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/DropMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetMarketCollectedSwapFees(ctx context.Context, in *GetMarketCollectedSwapFeesRequest, opts ...grpc.CallOption) (*GetMarketCollectedSwapFeesReply, error) {
	out := new(GetMarketCollectedSwapFeesReply)
	err := c.cc.Invoke(ctx, "/Operator/GetMarketCollectedSwapFees", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) WithdrawMarket(ctx context.Context, in *WithdrawMarketRequest, opts ...grpc.CallOption) (*WithdrawMarketReply, error) {
	out := new(WithdrawMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/WithdrawMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) UpdateMarketPercentageFee(ctx context.Context, in *UpdateMarketPercentageFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error) {
	out := new(UpdateMarketFeeReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketPercentageFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) UpdateMarketFixedFee(ctx context.Context, in *UpdateMarketFixedFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error) {
	out := new(UpdateMarketFeeReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketFixedFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) UpdateMarketPrice(ctx context.Context, in *UpdateMarketPriceRequest, opts ...grpc.CallOption) (*UpdateMarketPriceReply, error) {
	out := new(UpdateMarketPriceReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) UpdateMarketStrategy(ctx context.Context, in *UpdateMarketStrategyRequest, opts ...grpc.CallOption) (*UpdateMarketStrategyReply, error) {
	out := new(UpdateMarketStrategyReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketStrategy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetFeeFragmenterAddress(ctx context.Context, in *GetFeeFragmenterAddressRequest, opts ...grpc.CallOption) (*GetFeeFragmenterAddressReply, error) {
	out := new(GetFeeFragmenterAddressReply)
	err := c.cc.Invoke(ctx, "/Operator/GetFeeFragmenterAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListFeeFragmenterAddresses(ctx context.Context, in *ListFeeFragmenterAddressesRequest, opts ...grpc.CallOption) (*ListFeeFragmenterAddressesReply, error) {
	out := new(ListFeeFragmenterAddressesReply)
	err := c.cc.Invoke(ctx, "/Operator/ListFeeFragmenterAddresses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetFeeFragmenterBalance(ctx context.Context, in *GetFeeFragmenterBalanceRequest, opts ...grpc.CallOption) (*GetFeeFragmenterBalanceReply, error) {
	out := new(GetFeeFragmenterBalanceReply)
	err := c.cc.Invoke(ctx, "/Operator/GetFeeFragmenterBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) FeeFragmenterSplitFunds(ctx context.Context, in *FeeFragmenterSplitFundsRequest, opts ...grpc.CallOption) (Operator_FeeFragmenterSplitFundsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Operator_ServiceDesc.Streams[0], "/Operator/FeeFragmenterSplitFunds", opts...)
	if err != nil {
		return nil, err
	}
	x := &operatorFeeFragmenterSplitFundsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Operator_FeeFragmenterSplitFundsClient interface {
	Recv() (*FragmenterSplitFundsReply, error)
	grpc.ClientStream
}

type operatorFeeFragmenterSplitFundsClient struct {
	grpc.ClientStream
}

func (x *operatorFeeFragmenterSplitFundsClient) Recv() (*FragmenterSplitFundsReply, error) {
	m := new(FragmenterSplitFundsReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *operatorClient) WithdrawFeeFragmenter(ctx context.Context, in *WithdrawFeeFragmenterRequest, opts ...grpc.CallOption) (*WithdrawFeeFragmenterReply, error) {
	out := new(WithdrawFeeFragmenterReply)
	err := c.cc.Invoke(ctx, "/Operator/WithdrawFeeFragmenter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetMarketFragmenterAddress(ctx context.Context, in *GetMarketFragmenterAddressRequest, opts ...grpc.CallOption) (*GetMarketFragmenterAddressReply, error) {
	out := new(GetMarketFragmenterAddressReply)
	err := c.cc.Invoke(ctx, "/Operator/GetMarketFragmenterAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListMarketFragmenterAddresses(ctx context.Context, in *ListMarketFragmenterAddressesRequest, opts ...grpc.CallOption) (*ListMarketFragmenterAddressesReply, error) {
	out := new(ListMarketFragmenterAddressesReply)
	err := c.cc.Invoke(ctx, "/Operator/ListMarketFragmenterAddresses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) GetMarketFragmenterBalance(ctx context.Context, in *GetMarketFragmenterBalanceRequest, opts ...grpc.CallOption) (*GetMarketFragmenterBalanceReply, error) {
	out := new(GetMarketFragmenterBalanceReply)
	err := c.cc.Invoke(ctx, "/Operator/GetMarketFragmenterBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) MarketFragmenterSplitFunds(ctx context.Context, in *MarketFragmenterSplitFundsRequest, opts ...grpc.CallOption) (Operator_MarketFragmenterSplitFundsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Operator_ServiceDesc.Streams[1], "/Operator/MarketFragmenterSplitFunds", opts...)
	if err != nil {
		return nil, err
	}
	x := &operatorMarketFragmenterSplitFundsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Operator_MarketFragmenterSplitFundsClient interface {
	Recv() (*FragmenterSplitFundsReply, error)
	grpc.ClientStream
}

type operatorMarketFragmenterSplitFundsClient struct {
	grpc.ClientStream
}

func (x *operatorMarketFragmenterSplitFundsClient) Recv() (*FragmenterSplitFundsReply, error) {
	m := new(FragmenterSplitFundsReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *operatorClient) WithdrawMarketFragmenter(ctx context.Context, in *WithdrawMarketFragmenterRequest, opts ...grpc.CallOption) (*WithdrawMarketFragmenterReply, error) {
	out := new(WithdrawMarketFragmenterReply)
	err := c.cc.Invoke(ctx, "/Operator/WithdrawMarketFragmenter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListMarkets(ctx context.Context, in *ListMarketsRequest, opts ...grpc.CallOption) (*ListMarketsReply, error) {
	out := new(ListMarketsReply)
	err := c.cc.Invoke(ctx, "/Operator/ListMarkets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesReply, error) {
	out := new(ListTradesReply)
	err := c.cc.Invoke(ctx, "/Operator/ListTrades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ReloadUtxos(ctx context.Context, in *ReloadUtxosRequest, opts ...grpc.CallOption) (*ReloadUtxosReply, error) {
	out := new(ReloadUtxosReply)
	err := c.cc.Invoke(ctx, "/Operator/ReloadUtxos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListUtxos(ctx context.Context, in *ListUtxosRequest, opts ...grpc.CallOption) (*ListUtxosReply, error) {
	out := new(ListUtxosReply)
	err := c.cc.Invoke(ctx, "/Operator/ListUtxos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) AddWebhook(ctx context.Context, in *AddWebhookRequest, opts ...grpc.CallOption) (*AddWebhookReply, error) {
	out := new(AddWebhookReply)
	err := c.cc.Invoke(ctx, "/Operator/AddWebhook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) RemoveWebhook(ctx context.Context, in *RemoveWebhookRequest, opts ...grpc.CallOption) (*RemoveWebhookReply, error) {
	out := new(RemoveWebhookReply)
	err := c.cc.Invoke(ctx, "/Operator/RemoveWebhook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListWebhooks(ctx context.Context, in *ListWebhooksRequest, opts ...grpc.CallOption) (*ListWebhooksReply, error) {
	out := new(ListWebhooksReply)
	err := c.cc.Invoke(ctx, "/Operator/ListWebhooks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListDeposits(ctx context.Context, in *ListDepositsRequest, opts ...grpc.CallOption) (*ListDepositsReply, error) {
	out := new(ListDepositsReply)
	err := c.cc.Invoke(ctx, "/Operator/ListDeposits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListWithdrawals(ctx context.Context, in *ListWithdrawalsRequest, opts ...grpc.CallOption) (*ListWithdrawalsReply, error) {
	out := new(ListWithdrawalsReply)
	err := c.cc.Invoke(ctx, "/Operator/ListWithdrawals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OperatorServer is the server API for Operator service.
// All implementations must embed UnimplementedOperatorServer
// for forward compatibility
type OperatorServer interface {
	// Returns info about the internal wallet of the daemon.
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoReply, error)
	// Returns some new derived address(es) from the fee account.
	// This is only used to deposit some LBTC to subsidize blockchain fees.
	GetFeeAddress(context.Context, *GetFeeAddressRequest) (*GetFeeAddressReply, error)
	// Returns the list of all derived addresses for the fee account.
	ListFeeAddresses(context.Context, *ListFeeAddressesRequest) (*ListFeeAddressesReply, error)
	// Returns info about the balance of LBTC held in the fee account.
	GetFeeBalance(context.Context, *GetFeeBalanceRequest) (*GetFeeBalanceReply, error)
	// Allows to provide transaction(s) outpoints of deposits made to fund the fee account.
	// The transaction(s) must be already included in blockchain.
	ClaimFeeDeposits(context.Context, *ClaimFeeDepositsRequest) (*ClaimFeeDepositsReply, error)
	// Allows to withdraw funds from the fee account to a given address.
	WithdrawFee(context.Context, *WithdrawFeeRequest) (*WithdrawFeeReply, error)
	// Creates a new market account in the daemon's wallet.
	NewMarket(context.Context, *NewMarketRequest) (*NewMarketReply, error)
	GetMarketInfo(context.Context, *GetMarketInfoRequest) (*GetMarketInfoReply, error)
	// Returns some new derived address(es) for the given market.
	GetMarketAddress(context.Context, *GetMarketAddressRequest) (*GetMarketAddressReply, error)
	// Returns the list of all derived addresses for the given market.
	ListMarketAddresses(context.Context, *ListMarketAddressesRequest) (*ListMarketAddressesReply, error)
	// Returns info about the balance of the given market.
	GetMarketBalance(context.Context, *GetMarketBalanceRequest) (*GetMarketBalanceReply, error)
	// Allows to provide transaction(s) outpoints of deposits made to fund a market.
	// The transaction(s) provided must be already included in blockchain.
	ClaimMarketDeposits(context.Context, *ClaimMarketDepositsRequest) (*ClaimMarketDepositsReply, error)
	// Makes the given market tradable.
	OpenMarket(context.Context, *OpenMarketRequest) (*OpenMarketReply, error)
	// Makes the given market NOT tradabale.
	CloseMarket(context.Context, *CloseMarketRequest) (*CloseMarketReply, error)
	// Deletes a market.
	DropMarket(context.Context, *DropMarketRequest) (*DropMarketReply, error)
	// Displays a report of the colected fees for the given market.
	GetMarketCollectedSwapFees(context.Context, *GetMarketCollectedSwapFeesRequest) (*GetMarketCollectedSwapFeesReply, error)
	// Allows to withdraw funds from the given market to a given address.
	WithdrawMarket(context.Context, *WithdrawMarketRequest) (*WithdrawMarketReply, error)
	// Changes the Liquidity Provider percentage fee for the given market.
	UpdateMarketPercentageFee(context.Context, *UpdateMarketPercentageFeeRequest) (*UpdateMarketFeeReply, error)
	// Changes the Liquidity provider fixed fees for the given market.
	UpdateMarketFixedFee(context.Context, *UpdateMarketFixedFeeRequest) (*UpdateMarketFeeReply, error)
	// Updates the price for the given market.
	UpdateMarketPrice(context.Context, *UpdateMarketPriceRequest) (*UpdateMarketPriceReply, error)
	// Updates the current market making strategy, either using an automated
	// market making formula or a pluggable price feed.
	UpdateMarketStrategy(context.Context, *UpdateMarketStrategyRequest) (*UpdateMarketStrategyReply, error)
	// Returns some new derived address(es) for the fee fragmenter account.
	GetFeeFragmenterAddress(context.Context, *GetFeeFragmenterAddressRequest) (*GetFeeFragmenterAddressReply, error)
	// Returns the list of all derived addresses for the fee fragmenter account.
	ListFeeFragmenterAddresses(context.Context, *ListFeeFragmenterAddressesRequest) (*ListFeeFragmenterAddressesReply, error)
	// Returns info about the balance of the fee fragmenter account.
	GetFeeFragmenterBalance(context.Context, *GetFeeFragmenterBalanceRequest) (*GetFeeFragmenterBalanceReply, error)
	// Splits the funds sent to the fee fragmenter account into multiple
	// fragments that then becomes deposits of the Fee account.
	FeeFragmenterSplitFunds(*FeeFragmenterSplitFundsRequest, Operator_FeeFragmenterSplitFundsServer) error
	// Allows to withdraw funds from the fee fragmenter account to a given address.
	WithdrawFeeFragmenter(context.Context, *WithdrawFeeFragmenterRequest) (*WithdrawFeeFragmenterReply, error)
	// Returns some new derived address(es) for the market fragmenter account.
	GetMarketFragmenterAddress(context.Context, *GetMarketFragmenterAddressRequest) (*GetMarketFragmenterAddressReply, error)
	// Returns the list of all derived addresses for the market fragmenter account.
	ListMarketFragmenterAddresses(context.Context, *ListMarketFragmenterAddressesRequest) (*ListMarketFragmenterAddressesReply, error)
	// Returns info about the balance of the market fragmenter account.
	GetMarketFragmenterBalance(context.Context, *GetMarketFragmenterBalanceRequest) (*GetMarketFragmenterBalanceReply, error)
	// Splits the funds sent to the market fragmenter account into multiple
	// fragments that then becomes deposits of the given market.
	MarketFragmenterSplitFunds(*MarketFragmenterSplitFundsRequest, Operator_MarketFragmenterSplitFundsServer) error
	// Allows to withdraw funds from the market fragmenter account to a given address.
	WithdrawMarketFragmenter(context.Context, *WithdrawMarketFragmenterRequest) (*WithdrawMarketFragmenterReply, error)
	// Get extended details for each market either open, closed or to be funded.
	ListMarkets(context.Context, *ListMarketsRequest) (*ListMarketsReply, error)
	// Returs all the trades processed by the daemon (ongoing, completed and
	// failed/rejected) or all those filtered by market.
	ListTrades(context.Context, *ListTradesRequest) (*ListTradesReply, error)
	// Causes the daemon to re-sync the whole utxo set.
	ReloadUtxos(context.Context, *ReloadUtxosRequest) (*ReloadUtxosReply, error)
	// Returns all the utxos, whether unspents, spents or locked.
	ListUtxos(context.Context, *ListUtxosRequest) (*ListUtxosReply, error)
	// Adds a webhook registered for some kind of event.
	AddWebhook(context.Context, *AddWebhookRequest) (*AddWebhookReply, error)
	// Removes some previously added webhook.
	RemoveWebhook(context.Context, *RemoveWebhookRequest) (*RemoveWebhookReply, error)
	// Returns registered webhooks
	ListWebhooks(context.Context, *ListWebhooksRequest) (*ListWebhooksReply, error)
	// Returns the list of all claimed deposits for the given account.
	ListDeposits(context.Context, *ListDepositsRequest) (*ListDepositsReply, error)
	// Returns the list of all withdrawals made for the given account.
	ListWithdrawals(context.Context, *ListWithdrawalsRequest) (*ListWithdrawalsReply, error)
	mustEmbedUnimplementedOperatorServer()
}

// UnimplementedOperatorServer must be embedded to have forward compatible implementations.
type UnimplementedOperatorServer struct {
}

func (UnimplementedOperatorServer) GetInfo(context.Context, *GetInfoRequest) (*GetInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfo not implemented")
}
func (UnimplementedOperatorServer) GetFeeAddress(context.Context, *GetFeeAddressRequest) (*GetFeeAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeeAddress not implemented")
}
func (UnimplementedOperatorServer) ListFeeAddresses(context.Context, *ListFeeAddressesRequest) (*ListFeeAddressesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFeeAddresses not implemented")
}
func (UnimplementedOperatorServer) GetFeeBalance(context.Context, *GetFeeBalanceRequest) (*GetFeeBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeeBalance not implemented")
}
func (UnimplementedOperatorServer) ClaimFeeDeposits(context.Context, *ClaimFeeDepositsRequest) (*ClaimFeeDepositsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimFeeDeposits not implemented")
}
func (UnimplementedOperatorServer) WithdrawFee(context.Context, *WithdrawFeeRequest) (*WithdrawFeeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawFee not implemented")
}
func (UnimplementedOperatorServer) NewMarket(context.Context, *NewMarketRequest) (*NewMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewMarket not implemented")
}
func (UnimplementedOperatorServer) GetMarketInfo(context.Context, *GetMarketInfoRequest) (*GetMarketInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarketInfo not implemented")
}
func (UnimplementedOperatorServer) GetMarketAddress(context.Context, *GetMarketAddressRequest) (*GetMarketAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarketAddress not implemented")
}
func (UnimplementedOperatorServer) ListMarketAddresses(context.Context, *ListMarketAddressesRequest) (*ListMarketAddressesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMarketAddresses not implemented")
}
func (UnimplementedOperatorServer) GetMarketBalance(context.Context, *GetMarketBalanceRequest) (*GetMarketBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarketBalance not implemented")
}
func (UnimplementedOperatorServer) ClaimMarketDeposits(context.Context, *ClaimMarketDepositsRequest) (*ClaimMarketDepositsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimMarketDeposits not implemented")
}
func (UnimplementedOperatorServer) OpenMarket(context.Context, *OpenMarketRequest) (*OpenMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenMarket not implemented")
}
func (UnimplementedOperatorServer) CloseMarket(context.Context, *CloseMarketRequest) (*CloseMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseMarket not implemented")
}
func (UnimplementedOperatorServer) DropMarket(context.Context, *DropMarketRequest) (*DropMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropMarket not implemented")
}
func (UnimplementedOperatorServer) GetMarketCollectedSwapFees(context.Context, *GetMarketCollectedSwapFeesRequest) (*GetMarketCollectedSwapFeesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarketCollectedSwapFees not implemented")
}
func (UnimplementedOperatorServer) WithdrawMarket(context.Context, *WithdrawMarketRequest) (*WithdrawMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawMarket not implemented")
}
func (UnimplementedOperatorServer) UpdateMarketPercentageFee(context.Context, *UpdateMarketPercentageFeeRequest) (*UpdateMarketFeeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketPercentageFee not implemented")
}
func (UnimplementedOperatorServer) UpdateMarketFixedFee(context.Context, *UpdateMarketFixedFeeRequest) (*UpdateMarketFeeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketFixedFee not implemented")
}
func (UnimplementedOperatorServer) UpdateMarketPrice(context.Context, *UpdateMarketPriceRequest) (*UpdateMarketPriceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketPrice not implemented")
}
func (UnimplementedOperatorServer) UpdateMarketStrategy(context.Context, *UpdateMarketStrategyRequest) (*UpdateMarketStrategyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketStrategy not implemented")
}
func (UnimplementedOperatorServer) GetFeeFragmenterAddress(context.Context, *GetFeeFragmenterAddressRequest) (*GetFeeFragmenterAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeeFragmenterAddress not implemented")
}
func (UnimplementedOperatorServer) ListFeeFragmenterAddresses(context.Context, *ListFeeFragmenterAddressesRequest) (*ListFeeFragmenterAddressesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFeeFragmenterAddresses not implemented")
}
func (UnimplementedOperatorServer) GetFeeFragmenterBalance(context.Context, *GetFeeFragmenterBalanceRequest) (*GetFeeFragmenterBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeeFragmenterBalance not implemented")
}
func (UnimplementedOperatorServer) FeeFragmenterSplitFunds(*FeeFragmenterSplitFundsRequest, Operator_FeeFragmenterSplitFundsServer) error {
	return status.Errorf(codes.Unimplemented, "method FeeFragmenterSplitFunds not implemented")
}
func (UnimplementedOperatorServer) WithdrawFeeFragmenter(context.Context, *WithdrawFeeFragmenterRequest) (*WithdrawFeeFragmenterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawFeeFragmenter not implemented")
}
func (UnimplementedOperatorServer) GetMarketFragmenterAddress(context.Context, *GetMarketFragmenterAddressRequest) (*GetMarketFragmenterAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarketFragmenterAddress not implemented")
}
func (UnimplementedOperatorServer) ListMarketFragmenterAddresses(context.Context, *ListMarketFragmenterAddressesRequest) (*ListMarketFragmenterAddressesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMarketFragmenterAddresses not implemented")
}
func (UnimplementedOperatorServer) GetMarketFragmenterBalance(context.Context, *GetMarketFragmenterBalanceRequest) (*GetMarketFragmenterBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarketFragmenterBalance not implemented")
}
func (UnimplementedOperatorServer) MarketFragmenterSplitFunds(*MarketFragmenterSplitFundsRequest, Operator_MarketFragmenterSplitFundsServer) error {
	return status.Errorf(codes.Unimplemented, "method MarketFragmenterSplitFunds not implemented")
}
func (UnimplementedOperatorServer) WithdrawMarketFragmenter(context.Context, *WithdrawMarketFragmenterRequest) (*WithdrawMarketFragmenterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawMarketFragmenter not implemented")
}
func (UnimplementedOperatorServer) ListMarkets(context.Context, *ListMarketsRequest) (*ListMarketsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMarkets not implemented")
}
func (UnimplementedOperatorServer) ListTrades(context.Context, *ListTradesRequest) (*ListTradesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTrades not implemented")
}
func (UnimplementedOperatorServer) ReloadUtxos(context.Context, *ReloadUtxosRequest) (*ReloadUtxosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReloadUtxos not implemented")
}
func (UnimplementedOperatorServer) ListUtxos(context.Context, *ListUtxosRequest) (*ListUtxosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUtxos not implemented")
}
func (UnimplementedOperatorServer) AddWebhook(context.Context, *AddWebhookRequest) (*AddWebhookReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddWebhook not implemented")
}
func (UnimplementedOperatorServer) RemoveWebhook(context.Context, *RemoveWebhookRequest) (*RemoveWebhookReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveWebhook not implemented")
}
func (UnimplementedOperatorServer) ListWebhooks(context.Context, *ListWebhooksRequest) (*ListWebhooksReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWebhooks not implemented")
}
func (UnimplementedOperatorServer) ListDeposits(context.Context, *ListDepositsRequest) (*ListDepositsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDeposits not implemented")
}
func (UnimplementedOperatorServer) ListWithdrawals(context.Context, *ListWithdrawalsRequest) (*ListWithdrawalsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWithdrawals not implemented")
}
func (UnimplementedOperatorServer) mustEmbedUnimplementedOperatorServer() {}

// UnsafeOperatorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OperatorServer will
// result in compilation errors.
type UnsafeOperatorServer interface {
	mustEmbedUnimplementedOperatorServer()
}

func RegisterOperatorServer(s grpc.ServiceRegistrar, srv OperatorServer) {
	s.RegisterService(&Operator_ServiceDesc, srv)
}

func _Operator_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetFeeAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeeAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetFeeAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetFeeAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetFeeAddress(ctx, req.(*GetFeeAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListFeeAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFeeAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListFeeAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListFeeAddresses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListFeeAddresses(ctx, req.(*ListFeeAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetFeeBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeeBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetFeeBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetFeeBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetFeeBalance(ctx, req.(*GetFeeBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ClaimFeeDeposits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimFeeDepositsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ClaimFeeDeposits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ClaimFeeDeposits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ClaimFeeDeposits(ctx, req.(*ClaimFeeDepositsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_WithdrawFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).WithdrawFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/WithdrawFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).WithdrawFee(ctx, req.(*WithdrawFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_NewMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).NewMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/NewMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).NewMarket(ctx, req.(*NewMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetMarketInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarketInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetMarketInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetMarketInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetMarketInfo(ctx, req.(*GetMarketInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetMarketAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarketAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetMarketAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetMarketAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetMarketAddress(ctx, req.(*GetMarketAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListMarketAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMarketAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListMarketAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListMarketAddresses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListMarketAddresses(ctx, req.(*ListMarketAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetMarketBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarketBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetMarketBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetMarketBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetMarketBalance(ctx, req.(*GetMarketBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ClaimMarketDeposits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimMarketDepositsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ClaimMarketDeposits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ClaimMarketDeposits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ClaimMarketDeposits(ctx, req.(*ClaimMarketDepositsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_OpenMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).OpenMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/OpenMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).OpenMarket(ctx, req.(*OpenMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_CloseMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).CloseMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/CloseMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).CloseMarket(ctx, req.(*CloseMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_DropMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).DropMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/DropMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).DropMarket(ctx, req.(*DropMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetMarketCollectedSwapFees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarketCollectedSwapFeesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetMarketCollectedSwapFees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetMarketCollectedSwapFees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetMarketCollectedSwapFees(ctx, req.(*GetMarketCollectedSwapFeesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_WithdrawMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).WithdrawMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/WithdrawMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).WithdrawMarket(ctx, req.(*WithdrawMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_UpdateMarketPercentageFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketPercentageFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).UpdateMarketPercentageFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/UpdateMarketPercentageFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).UpdateMarketPercentageFee(ctx, req.(*UpdateMarketPercentageFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_UpdateMarketFixedFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketFixedFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).UpdateMarketFixedFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/UpdateMarketFixedFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).UpdateMarketFixedFee(ctx, req.(*UpdateMarketFixedFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_UpdateMarketPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).UpdateMarketPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/UpdateMarketPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).UpdateMarketPrice(ctx, req.(*UpdateMarketPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_UpdateMarketStrategy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketStrategyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).UpdateMarketStrategy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/UpdateMarketStrategy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).UpdateMarketStrategy(ctx, req.(*UpdateMarketStrategyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetFeeFragmenterAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeeFragmenterAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetFeeFragmenterAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetFeeFragmenterAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetFeeFragmenterAddress(ctx, req.(*GetFeeFragmenterAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListFeeFragmenterAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFeeFragmenterAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListFeeFragmenterAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListFeeFragmenterAddresses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListFeeFragmenterAddresses(ctx, req.(*ListFeeFragmenterAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetFeeFragmenterBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeeFragmenterBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetFeeFragmenterBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetFeeFragmenterBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetFeeFragmenterBalance(ctx, req.(*GetFeeFragmenterBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_FeeFragmenterSplitFunds_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FeeFragmenterSplitFundsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OperatorServer).FeeFragmenterSplitFunds(m, &operatorFeeFragmenterSplitFundsServer{stream})
}

type Operator_FeeFragmenterSplitFundsServer interface {
	Send(*FragmenterSplitFundsReply) error
	grpc.ServerStream
}

type operatorFeeFragmenterSplitFundsServer struct {
	grpc.ServerStream
}

func (x *operatorFeeFragmenterSplitFundsServer) Send(m *FragmenterSplitFundsReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Operator_WithdrawFeeFragmenter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawFeeFragmenterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).WithdrawFeeFragmenter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/WithdrawFeeFragmenter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).WithdrawFeeFragmenter(ctx, req.(*WithdrawFeeFragmenterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetMarketFragmenterAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarketFragmenterAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetMarketFragmenterAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetMarketFragmenterAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetMarketFragmenterAddress(ctx, req.(*GetMarketFragmenterAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListMarketFragmenterAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMarketFragmenterAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListMarketFragmenterAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListMarketFragmenterAddresses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListMarketFragmenterAddresses(ctx, req.(*ListMarketFragmenterAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_GetMarketFragmenterBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarketFragmenterBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).GetMarketFragmenterBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/GetMarketFragmenterBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).GetMarketFragmenterBalance(ctx, req.(*GetMarketFragmenterBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_MarketFragmenterSplitFunds_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MarketFragmenterSplitFundsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OperatorServer).MarketFragmenterSplitFunds(m, &operatorMarketFragmenterSplitFundsServer{stream})
}

type Operator_MarketFragmenterSplitFundsServer interface {
	Send(*FragmenterSplitFundsReply) error
	grpc.ServerStream
}

type operatorMarketFragmenterSplitFundsServer struct {
	grpc.ServerStream
}

func (x *operatorMarketFragmenterSplitFundsServer) Send(m *FragmenterSplitFundsReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Operator_WithdrawMarketFragmenter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawMarketFragmenterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).WithdrawMarketFragmenter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/WithdrawMarketFragmenter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).WithdrawMarketFragmenter(ctx, req.(*WithdrawMarketFragmenterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListMarkets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMarketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListMarkets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListMarkets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListMarkets(ctx, req.(*ListMarketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTradesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListTrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListTrades(ctx, req.(*ListTradesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ReloadUtxos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReloadUtxosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ReloadUtxos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ReloadUtxos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ReloadUtxos(ctx, req.(*ReloadUtxosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListUtxos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUtxosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListUtxos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListUtxos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListUtxos(ctx, req.(*ListUtxosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_AddWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).AddWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/AddWebhook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).AddWebhook(ctx, req.(*AddWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_RemoveWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).RemoveWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/RemoveWebhook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).RemoveWebhook(ctx, req.(*RemoveWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListWebhooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWebhooksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListWebhooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListWebhooks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListWebhooks(ctx, req.(*ListWebhooksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListDeposits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDepositsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListDeposits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListDeposits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListDeposits(ctx, req.(*ListDepositsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListWithdrawals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWithdrawalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListWithdrawals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListWithdrawals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListWithdrawals(ctx, req.(*ListWithdrawalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Operator_ServiceDesc is the grpc.ServiceDesc for Operator service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Operator_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Operator",
	HandlerType: (*OperatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInfo",
			Handler:    _Operator_GetInfo_Handler,
		},
		{
			MethodName: "GetFeeAddress",
			Handler:    _Operator_GetFeeAddress_Handler,
		},
		{
			MethodName: "ListFeeAddresses",
			Handler:    _Operator_ListFeeAddresses_Handler,
		},
		{
			MethodName: "GetFeeBalance",
			Handler:    _Operator_GetFeeBalance_Handler,
		},
		{
			MethodName: "ClaimFeeDeposits",
			Handler:    _Operator_ClaimFeeDeposits_Handler,
		},
		{
			MethodName: "WithdrawFee",
			Handler:    _Operator_WithdrawFee_Handler,
		},
		{
			MethodName: "NewMarket",
			Handler:    _Operator_NewMarket_Handler,
		},
		{
			MethodName: "GetMarketInfo",
			Handler:    _Operator_GetMarketInfo_Handler,
		},
		{
			MethodName: "GetMarketAddress",
			Handler:    _Operator_GetMarketAddress_Handler,
		},
		{
			MethodName: "ListMarketAddresses",
			Handler:    _Operator_ListMarketAddresses_Handler,
		},
		{
			MethodName: "GetMarketBalance",
			Handler:    _Operator_GetMarketBalance_Handler,
		},
		{
			MethodName: "ClaimMarketDeposits",
			Handler:    _Operator_ClaimMarketDeposits_Handler,
		},
		{
			MethodName: "OpenMarket",
			Handler:    _Operator_OpenMarket_Handler,
		},
		{
			MethodName: "CloseMarket",
			Handler:    _Operator_CloseMarket_Handler,
		},
		{
			MethodName: "DropMarket",
			Handler:    _Operator_DropMarket_Handler,
		},
		{
			MethodName: "GetMarketCollectedSwapFees",
			Handler:    _Operator_GetMarketCollectedSwapFees_Handler,
		},
		{
			MethodName: "WithdrawMarket",
			Handler:    _Operator_WithdrawMarket_Handler,
		},
		{
			MethodName: "UpdateMarketPercentageFee",
			Handler:    _Operator_UpdateMarketPercentageFee_Handler,
		},
		{
			MethodName: "UpdateMarketFixedFee",
			Handler:    _Operator_UpdateMarketFixedFee_Handler,
		},
		{
			MethodName: "UpdateMarketPrice",
			Handler:    _Operator_UpdateMarketPrice_Handler,
		},
		{
			MethodName: "UpdateMarketStrategy",
			Handler:    _Operator_UpdateMarketStrategy_Handler,
		},
		{
			MethodName: "GetFeeFragmenterAddress",
			Handler:    _Operator_GetFeeFragmenterAddress_Handler,
		},
		{
			MethodName: "ListFeeFragmenterAddresses",
			Handler:    _Operator_ListFeeFragmenterAddresses_Handler,
		},
		{
			MethodName: "GetFeeFragmenterBalance",
			Handler:    _Operator_GetFeeFragmenterBalance_Handler,
		},
		{
			MethodName: "WithdrawFeeFragmenter",
			Handler:    _Operator_WithdrawFeeFragmenter_Handler,
		},
		{
			MethodName: "GetMarketFragmenterAddress",
			Handler:    _Operator_GetMarketFragmenterAddress_Handler,
		},
		{
			MethodName: "ListMarketFragmenterAddresses",
			Handler:    _Operator_ListMarketFragmenterAddresses_Handler,
		},
		{
			MethodName: "GetMarketFragmenterBalance",
			Handler:    _Operator_GetMarketFragmenterBalance_Handler,
		},
		{
			MethodName: "WithdrawMarketFragmenter",
			Handler:    _Operator_WithdrawMarketFragmenter_Handler,
		},
		{
			MethodName: "ListMarkets",
			Handler:    _Operator_ListMarkets_Handler,
		},
		{
			MethodName: "ListTrades",
			Handler:    _Operator_ListTrades_Handler,
		},
		{
			MethodName: "ReloadUtxos",
			Handler:    _Operator_ReloadUtxos_Handler,
		},
		{
			MethodName: "ListUtxos",
			Handler:    _Operator_ListUtxos_Handler,
		},
		{
			MethodName: "AddWebhook",
			Handler:    _Operator_AddWebhook_Handler,
		},
		{
			MethodName: "RemoveWebhook",
			Handler:    _Operator_RemoveWebhook_Handler,
		},
		{
			MethodName: "ListWebhooks",
			Handler:    _Operator_ListWebhooks_Handler,
		},
		{
			MethodName: "ListDeposits",
			Handler:    _Operator_ListDeposits_Handler,
		},
		{
			MethodName: "ListWithdrawals",
			Handler:    _Operator_ListWithdrawals_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FeeFragmenterSplitFunds",
			Handler:       _Operator_FeeFragmenterSplitFunds_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MarketFragmenterSplitFunds",
			Handler:       _Operator_MarketFragmenterSplitFunds_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "operator.proto",
}
