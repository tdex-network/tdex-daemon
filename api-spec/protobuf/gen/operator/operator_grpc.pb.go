// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package operator

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// OperatorClient is the client API for Operator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OperatorClient interface {
	// Returns a new derived address for the given market.
	// If market field is empty, a new Market is created and MUST be initialized.
	DepositMarket(ctx context.Context, in *DepositMarketRequest, opts ...grpc.CallOption) (*DepositMarketReply, error)
	// Returns the list of previously generated addresses for the given market.
	ListDepositMarket(ctx context.Context, in *ListDepositMarketRequest, opts ...grpc.CallOption) (*ListDepositMarketReply, error)
	// Returns a new derived address from the fee account.
	// This is only used to deposit some LBTC to subsidize blockchain fees.
	DepositFeeAccount(ctx context.Context, in *DepositFeeAccountRequest, opts ...grpc.CallOption) (*DepositFeeAccountReply, error)
	// Returns the aggregated balance of LBTC held in the fee account.
	BalanceFeeAccount(ctx context.Context, in *BalanceFeeAccountRequest, opts ...grpc.CallOption) (*BalanceFeeAccountReply, error)
	// Operator can provide transaction(s) outpoints of deposits made to fund a new market.
	// The transaction must be visible and confirmed, otherwise an error will be returned,
	// inviting the operator to retry again
	ClaimMarketDeposit(ctx context.Context, in *ClaimMarketDepositRequest, opts ...grpc.CallOption) (*ClaimMarketDepositReply, error)
	// Operator can provide transaction(s) outpoints of deposits made to fund the fee account.
	// The transaction must be visible and confirmed, otherwise an error will be returned,
	// inviting the operator to retry again
	ClaimFeeDeposit(ctx context.Context, in *ClaimFeeDepositRequest, opts ...grpc.CallOption) (*ClaimFeeDepositReply, error)
	// Makes the given market tradable
	OpenMarket(ctx context.Context, in *OpenMarketRequest, opts ...grpc.CallOption) (*OpenMarketReply, error)
	// Makes the given market NOT tradabale
	CloseMarket(ctx context.Context, in *CloseMarketRequest, opts ...grpc.CallOption) (*CloseMarketReply, error)
	// Get extended details for each markets either open, closed or to be funded.
	ListMarket(ctx context.Context, in *ListMarketRequest, opts ...grpc.CallOption) (*ListMarketReply, error)
	// Changes the Liquidity Provider percentage fee for the given market. It
	// should be express in basis point. To change the fee on each swap from
	// (current) 0.25% to 1% you need to pass down 100 The Market MUST be closed
	// before doing this change. It's also possible to remove the percentage fee
	// by setting it to 0.
	UpdateMarketPercentageFee(ctx context.Context, in *UpdateMarketPercentageFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error)
	// Changes the Liquidity provider fixed fees for the given market.
	// They should be expressed in satoshis for both assets of the market.
	// To remove a non-null fixed fee, it's enough to set the fields of the
	// request to 0.
	UpdateMarketFixedFee(ctx context.Context, in *UpdateMarketFixedFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error)
	// Manually updates the price for the given market
	UpdateMarketPrice(ctx context.Context, in *UpdateMarketPriceRequest, opts ...grpc.CallOption) (*UpdateMarketPriceReply, error)
	// Updates the current market making strategy, either using an automated
	// market making formula or a pluggable price feed
	UpdateMarketStrategy(ctx context.Context, in *UpdateMarketStrategyRequest, opts ...grpc.CallOption) (*UpdateMarketStrategyReply, error)
	// WithdrawMarket allows the operator to withdraw to external wallet funds
	// from a specific market. The Market MUST be closed before doing this change.
	WithdrawMarket(ctx context.Context, in *WithdrawMarketRequest, opts ...grpc.CallOption) (*WithdrawMarketReply, error)
	// Returs all the trades processed by the daemon (during process, compelted and rejected)
	ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesReply, error)
	// Displays a report on how much the given market is collecting in Liquidity
	// Provider fees
	ReportMarketFee(ctx context.Context, in *ReportMarketFeeRequest, opts ...grpc.CallOption) (*ReportMarketFeeReply, error)
	// Triggers reloading of unspents for stored addresses from blockchain
	ReloadUtxos(ctx context.Context, in *ReloadUtxosRequest, opts ...grpc.CallOption) (*ReloadUtxosReply, error)
	// Returns all the unspents and locks
	ListUtxos(ctx context.Context, in *ListUtxosRequest, opts ...grpc.CallOption) (*ListUtxosReply, error)
	// Deletes Market based on account_index
	DropMarket(ctx context.Context, in *DropMarketRequest, opts ...grpc.CallOption) (*DropMarketReply, error)
	// Adds a webhook registered for some kind of event.
	AddWebhook(ctx context.Context, in *AddWebhookRequest, opts ...grpc.CallOption) (*AddWebhookReply, error)
	// Removes some previously added webhook.
	RemoveWebhook(ctx context.Context, in *RemoveWebhookRequest, opts ...grpc.CallOption) (*RemoveWebhookReply, error)
	ListWebhooks(ctx context.Context, in *ListWebhooksRequest, opts ...grpc.CallOption) (*ListWebhooksReply, error)
}

type operatorClient struct {
	cc grpc.ClientConnInterface
}

func NewOperatorClient(cc grpc.ClientConnInterface) OperatorClient {
	return &operatorClient{cc}
}

func (c *operatorClient) DepositMarket(ctx context.Context, in *DepositMarketRequest, opts ...grpc.CallOption) (*DepositMarketReply, error) {
	out := new(DepositMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/DepositMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListDepositMarket(ctx context.Context, in *ListDepositMarketRequest, opts ...grpc.CallOption) (*ListDepositMarketReply, error) {
	out := new(ListDepositMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/ListDepositMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) DepositFeeAccount(ctx context.Context, in *DepositFeeAccountRequest, opts ...grpc.CallOption) (*DepositFeeAccountReply, error) {
	out := new(DepositFeeAccountReply)
	err := c.cc.Invoke(ctx, "/Operator/DepositFeeAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) BalanceFeeAccount(ctx context.Context, in *BalanceFeeAccountRequest, opts ...grpc.CallOption) (*BalanceFeeAccountReply, error) {
	out := new(BalanceFeeAccountReply)
	err := c.cc.Invoke(ctx, "/Operator/BalanceFeeAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ClaimMarketDeposit(ctx context.Context, in *ClaimMarketDepositRequest, opts ...grpc.CallOption) (*ClaimMarketDepositReply, error) {
	out := new(ClaimMarketDepositReply)
	err := c.cc.Invoke(ctx, "/Operator/ClaimMarketDeposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ClaimFeeDeposit(ctx context.Context, in *ClaimFeeDepositRequest, opts ...grpc.CallOption) (*ClaimFeeDepositReply, error) {
	out := new(ClaimFeeDepositReply)
	err := c.cc.Invoke(ctx, "/Operator/ClaimFeeDeposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) OpenMarket(ctx context.Context, in *OpenMarketRequest, opts ...grpc.CallOption) (*OpenMarketReply, error) {
	out := new(OpenMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/OpenMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) CloseMarket(ctx context.Context, in *CloseMarketRequest, opts ...grpc.CallOption) (*CloseMarketReply, error) {
	out := new(CloseMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/CloseMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListMarket(ctx context.Context, in *ListMarketRequest, opts ...grpc.CallOption) (*ListMarketReply, error) {
	out := new(ListMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/ListMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) UpdateMarketPercentageFee(ctx context.Context, in *UpdateMarketPercentageFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error) {
	out := new(UpdateMarketFeeReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketPercentageFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) UpdateMarketFixedFee(ctx context.Context, in *UpdateMarketFixedFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error) {
	out := new(UpdateMarketFeeReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketFixedFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) UpdateMarketPrice(ctx context.Context, in *UpdateMarketPriceRequest, opts ...grpc.CallOption) (*UpdateMarketPriceReply, error) {
	out := new(UpdateMarketPriceReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) UpdateMarketStrategy(ctx context.Context, in *UpdateMarketStrategyRequest, opts ...grpc.CallOption) (*UpdateMarketStrategyReply, error) {
	out := new(UpdateMarketStrategyReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketStrategy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) WithdrawMarket(ctx context.Context, in *WithdrawMarketRequest, opts ...grpc.CallOption) (*WithdrawMarketReply, error) {
	out := new(WithdrawMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/WithdrawMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesReply, error) {
	out := new(ListTradesReply)
	err := c.cc.Invoke(ctx, "/Operator/ListTrades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ReportMarketFee(ctx context.Context, in *ReportMarketFeeRequest, opts ...grpc.CallOption) (*ReportMarketFeeReply, error) {
	out := new(ReportMarketFeeReply)
	err := c.cc.Invoke(ctx, "/Operator/ReportMarketFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ReloadUtxos(ctx context.Context, in *ReloadUtxosRequest, opts ...grpc.CallOption) (*ReloadUtxosReply, error) {
	out := new(ReloadUtxosReply)
	err := c.cc.Invoke(ctx, "/Operator/ReloadUtxos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListUtxos(ctx context.Context, in *ListUtxosRequest, opts ...grpc.CallOption) (*ListUtxosReply, error) {
	out := new(ListUtxosReply)
	err := c.cc.Invoke(ctx, "/Operator/ListUtxos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) DropMarket(ctx context.Context, in *DropMarketRequest, opts ...grpc.CallOption) (*DropMarketReply, error) {
	out := new(DropMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/DropMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) AddWebhook(ctx context.Context, in *AddWebhookRequest, opts ...grpc.CallOption) (*AddWebhookReply, error) {
	out := new(AddWebhookReply)
	err := c.cc.Invoke(ctx, "/Operator/AddWebhook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) RemoveWebhook(ctx context.Context, in *RemoveWebhookRequest, opts ...grpc.CallOption) (*RemoveWebhookReply, error) {
	out := new(RemoveWebhookReply)
	err := c.cc.Invoke(ctx, "/Operator/RemoveWebhook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operatorClient) ListWebhooks(ctx context.Context, in *ListWebhooksRequest, opts ...grpc.CallOption) (*ListWebhooksReply, error) {
	out := new(ListWebhooksReply)
	err := c.cc.Invoke(ctx, "/Operator/ListWebhooks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OperatorServer is the server API for Operator service.
// All implementations must embed UnimplementedOperatorServer
// for forward compatibility
type OperatorServer interface {
	// Returns a new derived address for the given market.
	// If market field is empty, a new Market is created and MUST be initialized.
	DepositMarket(context.Context, *DepositMarketRequest) (*DepositMarketReply, error)
	// Returns the list of previously generated addresses for the given market.
	ListDepositMarket(context.Context, *ListDepositMarketRequest) (*ListDepositMarketReply, error)
	// Returns a new derived address from the fee account.
	// This is only used to deposit some LBTC to subsidize blockchain fees.
	DepositFeeAccount(context.Context, *DepositFeeAccountRequest) (*DepositFeeAccountReply, error)
	// Returns the aggregated balance of LBTC held in the fee account.
	BalanceFeeAccount(context.Context, *BalanceFeeAccountRequest) (*BalanceFeeAccountReply, error)
	// Operator can provide transaction(s) outpoints of deposits made to fund a new market.
	// The transaction must be visible and confirmed, otherwise an error will be returned,
	// inviting the operator to retry again
	ClaimMarketDeposit(context.Context, *ClaimMarketDepositRequest) (*ClaimMarketDepositReply, error)
	// Operator can provide transaction(s) outpoints of deposits made to fund the fee account.
	// The transaction must be visible and confirmed, otherwise an error will be returned,
	// inviting the operator to retry again
	ClaimFeeDeposit(context.Context, *ClaimFeeDepositRequest) (*ClaimFeeDepositReply, error)
	// Makes the given market tradable
	OpenMarket(context.Context, *OpenMarketRequest) (*OpenMarketReply, error)
	// Makes the given market NOT tradabale
	CloseMarket(context.Context, *CloseMarketRequest) (*CloseMarketReply, error)
	// Get extended details for each markets either open, closed or to be funded.
	ListMarket(context.Context, *ListMarketRequest) (*ListMarketReply, error)
	// Changes the Liquidity Provider percentage fee for the given market. It
	// should be express in basis point. To change the fee on each swap from
	// (current) 0.25% to 1% you need to pass down 100 The Market MUST be closed
	// before doing this change. It's also possible to remove the percentage fee
	// by setting it to 0.
	UpdateMarketPercentageFee(context.Context, *UpdateMarketPercentageFeeRequest) (*UpdateMarketFeeReply, error)
	// Changes the Liquidity provider fixed fees for the given market.
	// They should be expressed in satoshis for both assets of the market.
	// To remove a non-null fixed fee, it's enough to set the fields of the
	// request to 0.
	UpdateMarketFixedFee(context.Context, *UpdateMarketFixedFeeRequest) (*UpdateMarketFeeReply, error)
	// Manually updates the price for the given market
	UpdateMarketPrice(context.Context, *UpdateMarketPriceRequest) (*UpdateMarketPriceReply, error)
	// Updates the current market making strategy, either using an automated
	// market making formula or a pluggable price feed
	UpdateMarketStrategy(context.Context, *UpdateMarketStrategyRequest) (*UpdateMarketStrategyReply, error)
	// WithdrawMarket allows the operator to withdraw to external wallet funds
	// from a specific market. The Market MUST be closed before doing this change.
	WithdrawMarket(context.Context, *WithdrawMarketRequest) (*WithdrawMarketReply, error)
	// Returs all the trades processed by the daemon (during process, compelted and rejected)
	ListTrades(context.Context, *ListTradesRequest) (*ListTradesReply, error)
	// Displays a report on how much the given market is collecting in Liquidity
	// Provider fees
	ReportMarketFee(context.Context, *ReportMarketFeeRequest) (*ReportMarketFeeReply, error)
	// Triggers reloading of unspents for stored addresses from blockchain
	ReloadUtxos(context.Context, *ReloadUtxosRequest) (*ReloadUtxosReply, error)
	// Returns all the unspents and locks
	ListUtxos(context.Context, *ListUtxosRequest) (*ListUtxosReply, error)
	// Deletes Market based on account_index
	DropMarket(context.Context, *DropMarketRequest) (*DropMarketReply, error)
	// Adds a webhook registered for some kind of event.
	AddWebhook(context.Context, *AddWebhookRequest) (*AddWebhookReply, error)
	// Removes some previously added webhook.
	RemoveWebhook(context.Context, *RemoveWebhookRequest) (*RemoveWebhookReply, error)
	ListWebhooks(context.Context, *ListWebhooksRequest) (*ListWebhooksReply, error)
	mustEmbedUnimplementedOperatorServer()
}

// UnimplementedOperatorServer must be embedded to have forward compatible implementations.
type UnimplementedOperatorServer struct {
}

func (UnimplementedOperatorServer) DepositMarket(context.Context, *DepositMarketRequest) (*DepositMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositMarket not implemented")
}
func (UnimplementedOperatorServer) ListDepositMarket(context.Context, *ListDepositMarketRequest) (*ListDepositMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDepositMarket not implemented")
}
func (UnimplementedOperatorServer) DepositFeeAccount(context.Context, *DepositFeeAccountRequest) (*DepositFeeAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositFeeAccount not implemented")
}
func (UnimplementedOperatorServer) BalanceFeeAccount(context.Context, *BalanceFeeAccountRequest) (*BalanceFeeAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BalanceFeeAccount not implemented")
}
func (UnimplementedOperatorServer) ClaimMarketDeposit(context.Context, *ClaimMarketDepositRequest) (*ClaimMarketDepositReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimMarketDeposit not implemented")
}
func (UnimplementedOperatorServer) ClaimFeeDeposit(context.Context, *ClaimFeeDepositRequest) (*ClaimFeeDepositReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimFeeDeposit not implemented")
}
func (UnimplementedOperatorServer) OpenMarket(context.Context, *OpenMarketRequest) (*OpenMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenMarket not implemented")
}
func (UnimplementedOperatorServer) CloseMarket(context.Context, *CloseMarketRequest) (*CloseMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseMarket not implemented")
}
func (UnimplementedOperatorServer) ListMarket(context.Context, *ListMarketRequest) (*ListMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMarket not implemented")
}
func (UnimplementedOperatorServer) UpdateMarketPercentageFee(context.Context, *UpdateMarketPercentageFeeRequest) (*UpdateMarketFeeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketPercentageFee not implemented")
}
func (UnimplementedOperatorServer) UpdateMarketFixedFee(context.Context, *UpdateMarketFixedFeeRequest) (*UpdateMarketFeeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketFixedFee not implemented")
}
func (UnimplementedOperatorServer) UpdateMarketPrice(context.Context, *UpdateMarketPriceRequest) (*UpdateMarketPriceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketPrice not implemented")
}
func (UnimplementedOperatorServer) UpdateMarketStrategy(context.Context, *UpdateMarketStrategyRequest) (*UpdateMarketStrategyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketStrategy not implemented")
}
func (UnimplementedOperatorServer) WithdrawMarket(context.Context, *WithdrawMarketRequest) (*WithdrawMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawMarket not implemented")
}
func (UnimplementedOperatorServer) ListTrades(context.Context, *ListTradesRequest) (*ListTradesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTrades not implemented")
}
func (UnimplementedOperatorServer) ReportMarketFee(context.Context, *ReportMarketFeeRequest) (*ReportMarketFeeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportMarketFee not implemented")
}
func (UnimplementedOperatorServer) ReloadUtxos(context.Context, *ReloadUtxosRequest) (*ReloadUtxosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReloadUtxos not implemented")
}
func (UnimplementedOperatorServer) ListUtxos(context.Context, *ListUtxosRequest) (*ListUtxosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUtxos not implemented")
}
func (UnimplementedOperatorServer) DropMarket(context.Context, *DropMarketRequest) (*DropMarketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropMarket not implemented")
}
func (UnimplementedOperatorServer) AddWebhook(context.Context, *AddWebhookRequest) (*AddWebhookReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddWebhook not implemented")
}
func (UnimplementedOperatorServer) RemoveWebhook(context.Context, *RemoveWebhookRequest) (*RemoveWebhookReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveWebhook not implemented")
}
func (UnimplementedOperatorServer) ListWebhooks(context.Context, *ListWebhooksRequest) (*ListWebhooksReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWebhooks not implemented")
}
func (UnimplementedOperatorServer) mustEmbedUnimplementedOperatorServer() {}

// UnsafeOperatorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OperatorServer will
// result in compilation errors.
type UnsafeOperatorServer interface {
	mustEmbedUnimplementedOperatorServer()
}

func RegisterOperatorServer(s grpc.ServiceRegistrar, srv OperatorServer) {
	s.RegisterService(&_Operator_serviceDesc, srv)
}

func _Operator_DepositMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).DepositMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/DepositMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).DepositMarket(ctx, req.(*DepositMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListDepositMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDepositMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListDepositMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListDepositMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListDepositMarket(ctx, req.(*ListDepositMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_DepositFeeAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositFeeAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).DepositFeeAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/DepositFeeAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).DepositFeeAccount(ctx, req.(*DepositFeeAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_BalanceFeeAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BalanceFeeAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).BalanceFeeAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/BalanceFeeAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).BalanceFeeAccount(ctx, req.(*BalanceFeeAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ClaimMarketDeposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimMarketDepositRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ClaimMarketDeposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ClaimMarketDeposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ClaimMarketDeposit(ctx, req.(*ClaimMarketDepositRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ClaimFeeDeposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimFeeDepositRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ClaimFeeDeposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ClaimFeeDeposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ClaimFeeDeposit(ctx, req.(*ClaimFeeDepositRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_OpenMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).OpenMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/OpenMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).OpenMarket(ctx, req.(*OpenMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_CloseMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).CloseMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/CloseMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).CloseMarket(ctx, req.(*CloseMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListMarket(ctx, req.(*ListMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_UpdateMarketPercentageFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketPercentageFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).UpdateMarketPercentageFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/UpdateMarketPercentageFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).UpdateMarketPercentageFee(ctx, req.(*UpdateMarketPercentageFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_UpdateMarketFixedFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketFixedFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).UpdateMarketFixedFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/UpdateMarketFixedFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).UpdateMarketFixedFee(ctx, req.(*UpdateMarketFixedFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_UpdateMarketPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).UpdateMarketPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/UpdateMarketPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).UpdateMarketPrice(ctx, req.(*UpdateMarketPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_UpdateMarketStrategy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketStrategyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).UpdateMarketStrategy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/UpdateMarketStrategy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).UpdateMarketStrategy(ctx, req.(*UpdateMarketStrategyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_WithdrawMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).WithdrawMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/WithdrawMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).WithdrawMarket(ctx, req.(*WithdrawMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTradesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListTrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListTrades(ctx, req.(*ListTradesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ReportMarketFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportMarketFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ReportMarketFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ReportMarketFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ReportMarketFee(ctx, req.(*ReportMarketFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ReloadUtxos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReloadUtxosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ReloadUtxos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ReloadUtxos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ReloadUtxos(ctx, req.(*ReloadUtxosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListUtxos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUtxosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListUtxos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListUtxos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListUtxos(ctx, req.(*ListUtxosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_DropMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).DropMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/DropMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).DropMarket(ctx, req.(*DropMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_AddWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).AddWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/AddWebhook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).AddWebhook(ctx, req.(*AddWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_RemoveWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).RemoveWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/RemoveWebhook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).RemoveWebhook(ctx, req.(*RemoveWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Operator_ListWebhooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWebhooksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperatorServer).ListWebhooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Operator/ListWebhooks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperatorServer).ListWebhooks(ctx, req.(*ListWebhooksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Operator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Operator",
	HandlerType: (*OperatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DepositMarket",
			Handler:    _Operator_DepositMarket_Handler,
		},
		{
			MethodName: "ListDepositMarket",
			Handler:    _Operator_ListDepositMarket_Handler,
		},
		{
			MethodName: "DepositFeeAccount",
			Handler:    _Operator_DepositFeeAccount_Handler,
		},
		{
			MethodName: "BalanceFeeAccount",
			Handler:    _Operator_BalanceFeeAccount_Handler,
		},
		{
			MethodName: "ClaimMarketDeposit",
			Handler:    _Operator_ClaimMarketDeposit_Handler,
		},
		{
			MethodName: "ClaimFeeDeposit",
			Handler:    _Operator_ClaimFeeDeposit_Handler,
		},
		{
			MethodName: "OpenMarket",
			Handler:    _Operator_OpenMarket_Handler,
		},
		{
			MethodName: "CloseMarket",
			Handler:    _Operator_CloseMarket_Handler,
		},
		{
			MethodName: "ListMarket",
			Handler:    _Operator_ListMarket_Handler,
		},
		{
			MethodName: "UpdateMarketPercentageFee",
			Handler:    _Operator_UpdateMarketPercentageFee_Handler,
		},
		{
			MethodName: "UpdateMarketFixedFee",
			Handler:    _Operator_UpdateMarketFixedFee_Handler,
		},
		{
			MethodName: "UpdateMarketPrice",
			Handler:    _Operator_UpdateMarketPrice_Handler,
		},
		{
			MethodName: "UpdateMarketStrategy",
			Handler:    _Operator_UpdateMarketStrategy_Handler,
		},
		{
			MethodName: "WithdrawMarket",
			Handler:    _Operator_WithdrawMarket_Handler,
		},
		{
			MethodName: "ListTrades",
			Handler:    _Operator_ListTrades_Handler,
		},
		{
			MethodName: "ReportMarketFee",
			Handler:    _Operator_ReportMarketFee_Handler,
		},
		{
			MethodName: "ReloadUtxos",
			Handler:    _Operator_ReloadUtxos_Handler,
		},
		{
			MethodName: "ListUtxos",
			Handler:    _Operator_ListUtxos_Handler,
		},
		{
			MethodName: "DropMarket",
			Handler:    _Operator_DropMarket_Handler,
		},
		{
			MethodName: "AddWebhook",
			Handler:    _Operator_AddWebhook_Handler,
		},
		{
			MethodName: "RemoveWebhook",
			Handler:    _Operator_RemoveWebhook_Handler,
		},
		{
			MethodName: "ListWebhooks",
			Handler:    _Operator_ListWebhooks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "operator.proto",
}
